<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FanXing28</title>
  
  
  <link href="https://fanxing28.github.io/atom.xml" rel="self"/>
  
  <link href="https://fanxing28.github.io/"/>
  <updated>2023-12-14T14:56:23.664Z</updated>
  <id>https://fanxing28.github.io/</id>
  
  <author>
    <name>繁星ツ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS 面向对象和构造函数</title>
    <link href="https://fanxing28.github.io/2023/12/14/%E5%89%8D%E7%AB%AF/JavaScript/JS%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>https://fanxing28.github.io/2023/12/14/%E5%89%8D%E7%AB%AF/JavaScript/JS%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</id>
    <published>2023-12-14T14:48:00.000Z</published>
    <updated>2023-12-14T14:56:23.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-面向对象和面向过程"><a href="#一-面向对象和面向过程" class="headerlink" title="一. 面向对象和面向过程"></a>一. 面向对象和面向过程</h2><h3 id="1-面向过程的基本概念"><a href="#1-面向过程的基本概念" class="headerlink" title="(1) 面向过程的基本概念"></a>(1) 面向过程的基本概念</h3><p>面向过程(Procedure Oriented)是一种<strong>以过程为中心</strong>的编程思想。<br><strong>面向过程</strong>就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。是一种思考问题的基础方法。</p><blockquote><p><strong>简单理解</strong>：面向过程就是任何事情都亲力亲为，很机械，像个步兵。</p></blockquote><h3 id="2-面向对象的基本概念"><a href="#2-面向对象的基本概念" class="headerlink" title="(2) 面向对象的基本概念"></a>(2) 面向对象的基本概念</h3><p>面向对象(Object Oriented)是软件开发方法中的一种；是一种对现实世界理解和抽象的方法；是思考问题相对高级的方法。<br><strong>面向对象是把构成问题事务分解成各个对象</strong>，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。</p><blockquote><p><strong>简单理解</strong>：面向对象就像战场上的指挥官，指挥战斗而不必知道具体执行的过程。</p></blockquote><p><strong>注</strong>：面向对象：对象来自于类，必须先有类在有对象，类在js中也叫构造函数。<br><strong>面向对象和面向过程的联系</strong>：面向对象就是面向过程的封装。</p><h2 id="二-面向对象和面向过程的区别"><a href="#二-面向对象和面向过程的区别" class="headerlink" title="二. 面向对象和面向过程的区别"></a>二. 面向对象和面向过程的区别</h2><ol><li>面向对象是相对面向过程而言的，面向对象包含了面向过程的思想。</li><li>面向过程就是分析出解决问题所需要的步骤，关注的是解决问题需要那些步骤。</li><li>面向对象是把构成问题事务分解成各个对象，关注的是解决问题需要那些对象。</li></ol><h2 id="三-构造函数的推导"><a href="#三-构造函数的推导" class="headerlink" title="三. 构造函数的推导"></a>三. 构造函数的推导</h2><p><strong>推导过程</strong>:star2:：面向对象 &#x3D;&gt; 对象 &#x3D;&gt; 创建对象 &#x3D;&gt; 代码冗余 &#x3D;&gt; 工厂函数 &#x3D;&gt; 识别问题 &#x3D;&gt; 以系统对象为参考 &#x3D;&gt; 推导出构造函数<br><strong>详细的推导过程</strong>：</p><ol><li>首先，创建一个对象，添加属性和方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj1.<span class="property">name</span> = <span class="string">&#x27;zs&#x27;</span>;</span><br><span class="line">obj1.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">obj1.<span class="property">showinfo</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我的名字叫<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,我今年<span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>岁`</span>);</span><br><span class="line">&#125;;</span><br><span class="line">obj1.<span class="title function_">showinfo</span>() <span class="comment">// 我的名字叫zs,我今年18岁</span></span><br></pre></td></tr></table></figure>提到创建一个对象，是不是想问，可不可以创建多个对象&#x3D;&gt;可以，最原始的方法：重复创建。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj1.<span class="property">name</span> = <span class="string">&#x27;zs&#x27;</span>;</span><br><span class="line">obj1.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">obj1.<span class="property">showinfo</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我的名字叫<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,我今年<span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>岁`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj2.<span class="property">name</span> = <span class="string">&#x27;lisi&#x27;</span>;</span><br><span class="line">obj2.<span class="property">age</span> = <span class="number">17</span>;</span><br><span class="line">obj2.<span class="property">showinfo</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我的名字叫<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,我今年<span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>岁`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj3 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj3.<span class="property">name</span> = <span class="string">&#x27;wangwu&#x27;</span>;</span><br><span class="line">obj3.<span class="property">age</span> = <span class="number">19</span>;</span><br><span class="line">obj3.<span class="property">showinfo</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我的名字叫<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,我今年<span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>岁`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>显然上述创建多个对象的方式非常的麻烦，而且造成了代码的冗余，此时有什么办法可以解决呢:question: &#x3D;&gt; <strong>函数封装</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age</span>) &#123; </span><br><span class="line">    <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    obj.<span class="property">name</span> = name</span><br><span class="line">    obj.<span class="property">age</span> = age;</span><br><span class="line">    obj.<span class="property">showinfo</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我的名字叫<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,我今年<span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>岁`</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="title function_">createPerson</span>(<span class="string">&#x27;zs&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">name</span>); <span class="comment">// zs</span></span><br><span class="line">obj1.<span class="title function_">showinfo</span>(); <span class="comment">// 我的名字叫zs,我今年18岁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title function_">createPerson</span>(<span class="string">&#x27;lisi&#x27;</span>, <span class="number">17</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">name</span>); <span class="comment">// lisi</span></span><br><span class="line">obj2.<span class="title function_">showinfo</span>(); <span class="comment">// 我的名字叫lisi,我今年17岁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj3 = <span class="title function_">createPerson</span>(<span class="string">&#x27;wangwu&#x27;</span>, <span class="number">19</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj3.<span class="property">name</span>); <span class="comment">// wangwu</span></span><br><span class="line">obj3.<span class="title function_">showinfo</span>(); <span class="comment">// 我的名字叫wangwu,我今年19岁</span></span><br></pre></td></tr></table></figure><strong>注</strong>：封装完成，可以解决创建多个对象代码冗余问题，而且将这一函数称之为<strong>工厂函数</strong>。</li><li>此时，使用函数封装确实可以解决创建多个对象代码冗余问题，但是工厂函数无法解决识别问题。无法像Array，Date一样虽然属于对象，拥有自己独立的名称。<blockquote><p>因为创建的对象都是基于new Object()完成的，通过工厂函数看得见的。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age</span>) &#123; <span class="comment">// 工厂函数</span></span><br><span class="line">    <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    obj.<span class="property">name</span> = name</span><br><span class="line">    obj.<span class="property">age</span> = age;</span><br><span class="line">    obj.<span class="property">showinfo</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我的名字叫<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,我今年<span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>岁`</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>继续<strong>以系统对象为参考</strong>，于是在调用函数的前面<strong>添加new关键字</strong>，得到最终构造函数。<br> <strong>构造函数</strong>：new关键字调用，首字母大写，根据前面的概念，构造函数就是类，同时也知道系统的类是如何产生的。<br> 以 new 操作符调用函数的时候，函数内部发生以下变化：<br>1.创建一个空对象，并且this变量引用该对象，同时还继承了该函数的原型。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">CreatePerson</span>(<span class="params">name, age</span>) &#123; <span class="comment">// 构造函数，构造函数里面的this指向实例对象，createPerson:类(构造函数)</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name; <span class="comment">// 属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age; <span class="comment">// 属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">showinfo</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 方法</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我的名字叫<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,我今年<span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>岁`</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="title class_">CreatePerson</span>(<span class="string">&#x27;zs&#x27;</span>, <span class="number">18</span>); <span class="comment">// obj1:实例对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">name</span>);</span><br><span class="line">obj1.<span class="title function_">showinfo</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="keyword">new</span> <span class="title class_">CreatePerson</span>(<span class="string">&#x27;lisi&#x27;</span>, <span class="number">17</span>); <span class="comment">// obj2:实例对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">name</span>);</span><br><span class="line">obj2.<span class="title function_">showinfo</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj3 = <span class="keyword">new</span> <span class="title class_">CreatePerson</span>(<span class="string">&#x27;wangwu&#x27;</span>, <span class="number">19</span>); <span class="comment">// obj3:实例对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj3.<span class="property">name</span>);</span><br><span class="line">obj3.<span class="title function_">showinfo</span>();</span><br></pre></td></tr></table></figure><strong>注</strong>：构造函数里面不要书写return<blockquote><p>因为构造函数里没有显式调用return，默认返回的是this对象，也就是新创建的实例对象。</p></blockquote></li></ol><p>2.属性和方法被加入到this引用的对象中。<br>3.并且最后隐式的返回this。</p><h2 id="四-构造函数"><a href="#四-构造函数" class="headerlink" title="四. 构造函数"></a>四. 构造函数</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="(1) 概念"></a>(1) 概念</h3><p>构造函数其实就是一个函数，只不过使用的时候需要和new 关键字连用，首字母大写。</p><blockquote><p>和普通函数一样， 只不过调用的时候要和 new 调用 ，不然就是一个普通函数调用</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="keyword">function</span>(<span class="params">age</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>; <span class="comment">// 块作用域，外面无法获取，内部使用</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">2</span>; <span class="comment">// 局部变量，外面无法获取，内部使用</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age; <span class="comment">// 属性，实例对象可以自由获取，this-&gt;实例对象 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f1 = <span class="keyword">new</span> <span class="title function_">fn</span>(<span class="number">18</span>);</span><br><span class="line"><span class="keyword">let</span> f2 = <span class="keyword">new</span> fn; <span class="comment">// 这种写法也支持，弊端是无法传递参数</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>： 不写 new 的时候就是普通函数调用，没有创造对象的能力，但如果只是首字母不大写，只要和 new 连用，就有创造对象的能力。</p><h3 id="2-构造函数特点总结"><a href="#2-构造函数特点总结" class="headerlink" title="(2) 构造函数特点总结"></a>(2) 构造函数特点总结</h3><ol><li>首字母大写(推荐)<blockquote><p>方便区分</p></blockquote></li><li>构造函数里面不要书写return<br> 构造函数里没有显式调用return，默认返回的是this对象，也就是新创建的实例对象。<blockquote><p>当构造函数里调用return时，分两种情况：</p></blockquote></li></ol><ul><li>​ return的是五种简单数据类型：String，Number，Boolean，Null，Undefined。这种情况下，忽视return值，依然返回this对象。</li><li>​ return的是Object。这种情况下，不再返回this对象，而是返回return语句的返回值。</li></ul><ol start="3"><li>构造函数的调用必须和new连用<blockquote><p>只有和new连用，才有构造函数的能力，不和new连用，就是一个普通函数</p></blockquote></li><li>构造函数的this<blockquote><p>构造函数的this指向：本次调用被自动创建的对象</p></blockquote></li></ol><ul><li>自动创建出来的对象叫做 <strong>实例对象</strong></li><li>这个创建对象的过程叫做  <strong>实例化 的过程</strong></li></ul><ol start="5"><li>箭头函数没有this , 构造函数不能使用箭头函数书写<br><strong>构造函数的弊端</strong>：构造函数的方法也是私有的<br><strong>解决弊端的方式</strong>：将构造函数的方法书写在原型上</li></ol><h3 id="3-构造函数案例-memo"><a href="#3-构造函数案例-memo" class="headerlink" title="(3) 构造函数案例:memo:"></a>(3) 构造函数案例:memo:</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">left</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box2</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: orange;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">left</span>: <span class="number">600px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">Drag</span>(<span class="params">selector</span>) &#123; <span class="comment">// 创建拖拽的构造函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// this -&gt; 实例对象</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">box</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(selector); <span class="comment">// 属性</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">init</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 初始化方法</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">box</span>.<span class="property">onmousedown</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                e = e || event;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">let</span> sx = e.<span class="property">offsetX</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">let</span> sy = e.<span class="property">offsetY</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">document</span>.<span class="property">onmousemove</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    e = e || event;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">this</span>.<span class="property">box</span>.<span class="property">style</span>.<span class="property">left</span> = e.<span class="property">clientX</span> - sx + <span class="string">&#x27;px&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">this</span>.<span class="property">box</span>.<span class="property">style</span>.<span class="property">top</span> = e.<span class="property">clientY</span> - sy + <span class="string">&#x27;px&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">                &#125;;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">document</span>.<span class="property">onmouseup</span> = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">document</span>.<span class="property">onmousemove</span> = <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// let d1 = new Drag(&#x27;.box&#x27;);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// d1.init();</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// let d1 = new Drag;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// d1.init();</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Drag</span>(<span class="string">&#x27;.box&#x27;</span>).<span class="title function_">init</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Drag</span>(<span class="string">&#x27;.box1&#x27;</span>).<span class="title function_">init</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Drag</span>(<span class="string">&#x27;.box2&#x27;</span>).<span class="title function_">init</span>();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>效果图</strong>：<br>？</p>]]></content>
    
    
    <summary type="html">JS 面向对象和构造函数</summary>
    
    
    
    <category term="前端" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://fanxing28.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS 原型与原型链以及判断数据类型方式</title>
    <link href="https://fanxing28.github.io/2023/12/14/%E5%89%8D%E7%AB%AF/JavaScript/JS%20%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%BB%A5%E5%8F%8A%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%96%B9%E5%BC%8F/"/>
    <id>https://fanxing28.github.io/2023/12/14/%E5%89%8D%E7%AB%AF/JavaScript/JS%20%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%BB%A5%E5%8F%8A%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%96%B9%E5%BC%8F/</id>
    <published>2023-12-14T14:45:00.000Z</published>
    <updated>2023-12-14T14:56:23.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-原型（prototype）"><a href="#一-原型（prototype）" class="headerlink" title="一. 原型（prototype）"></a>一. 原型（prototype）</h2><blockquote><p>将公共的方法提取出来，都写在原型上（只用书写和创建一次）</p></blockquote><p>原型的出现是为了解决构造函数方法私有化问题。<br>在内置构造函数的原型上扩展一个新方法，所有的数组都可以使用这个方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getMin</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    min = <span class="title class_">Math</span>.<span class="title function_">min</span>(...<span class="variable language_">this</span>); <span class="comment">// this指向arr</span></span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">4</span>, <span class="number">23</span>, <span class="number">34</span>, <span class="number">11</span>, <span class="number">435</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">getMin</span>()); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p><strong>原型概念</strong>：</p><blockquote><p>每一个函数：天生自带一个属性 prototype（构造函数的原型也是一个对象）（叫做构造原型） 每一个对象：天生自带一个属性 <code>__proto__</code>（指向所属构造函数的原型）（叫做内置原型）</p></blockquote><p><strong>实例化对象</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure><ul><li>p 是 Person的实例对象</li><li>p 的构造函数是 Person</li><li>p 的 <code>__proto__</code> 指向 Person.prototype<br><strong>JS中内置的构造函数</strong>：</li><li>Object</li><li>Array</li><li>Date</li><li>RegExp</li><li>Function<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eg:</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>()</span><br><span class="line"><span class="comment">//  任何一个数组，所属的构造函数是 Array</span></span><br><span class="line"><span class="comment">//  任何一个对象，所属的构造函数是 Object</span></span><br></pre></td></tr></table></figure><strong>用数组为例</strong>：</li><li>任何一个数组，所属的构造函数都是Array</li><li>Array原型上的方法，都是给数组使用<br><strong>一切皆对象</strong></li><li>只要是 [] 所属的构造函数就是Array</li><li>只要是 {} 所属的构造函数就是Object</li><li>只要是 function () {} 所属的构造函数就是Function<br><strong>问答？</strong></li></ul><ol><li>原型是什么 ？<blockquote><p>一个对象，我们也称为 prototype 为原型对象。</p></blockquote></li><li>原型的作用是什么 ？<blockquote><p>共享方法。</p></blockquote></li><li>为什么要使用原型对象<blockquote><p>因为构造函数方法虽然很好用，但是存在浪费内存的问题。每一次调用构造函数中的方法都会重新开辟一块新的内存存储（浪费了空间），而原型对象（prototype）可以对象共享，可以节省内存。</p></blockquote></li></ol><h2 id="二-原型链"><a href="#二-原型链" class="headerlink" title="二. 原型链"></a>二. 原型链</h2><p><strong>原型链</strong>：使用<code>__proto__</code>串联起来的链状结构<br><strong>对象的访问机制</strong>：</p><ul><li>当访问一个对象成员的时候</li><li>首先在该对象自己身上查找，如果有直接使用，停止查找</li><li>如果没有，会自动去到<code>__proto__</code>查找，如果有直接使用，停止查找</li><li>如果仍然没有，继续去到<code>__proto__</code>在上一级查找</li><li>如果没有找到，返回undefined, （指向了原型链的顶级 null，表示该属性不存在）<br><strong>官方</strong>：每个实例对象（object）都有一个私有属性（称之为 <strong>proto</strong>）指向它的构造函数的原型对象（prototype）。该原型对象也有一个自己的原型对象（<strong>proto</strong>），层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  七个指向问题：(p ==&gt; Person的实例对象)</span></span><br><span class="line"><span class="comment">      寻找思路主要还是要先了解：该对象所属的构造函数是什么？</span></span><br><span class="line"><span class="comment">          （实例对象指向构造函数的原型）</span></span><br><span class="line"><span class="comment">          1.p.__pro__                     ==&gt; Person.prototype </span></span><br><span class="line"><span class="comment">          （构造函数的原型也是一个对象，所以构造函数的原型指向Object的原型）</span></span><br><span class="line"><span class="comment">          2.Person.prototype.__proto__    ==&gt; Object.prototype</span></span><br><span class="line"><span class="comment">          （构造函数是一个函数，所以构造函数指向Function的原型）</span></span><br><span class="line"><span class="comment">          3.Person.__proto__              ==&gt; Function.prototype</span></span><br><span class="line"><span class="comment">          （Function是一个函数，所以Function指向自身）</span></span><br><span class="line"><span class="comment">          4.Function.__proto__            ==&gt; Function.prototype</span></span><br><span class="line"><span class="comment">          （Object）</span></span><br><span class="line"><span class="comment">          5.Object.__proto__              ==&gt; Function.prototype</span></span><br><span class="line"><span class="comment">          （Function.prototype也是一个对象，所以Function的原型指向Object的原型）</span></span><br><span class="line"><span class="comment">          6.Function.prototype.__proto__  ==&gt; Object.prototype</span></span><br><span class="line"><span class="comment">          （Object的原型指向null(结束)）</span></span><br><span class="line"><span class="comment">          7.Object.prototype.__proto__    ==&gt; null</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   所以以下等式结果全为true</span></span><br><span class="line"><span class="comment">        p.__proto__ === Person.prototype</span></span><br><span class="line"><span class="comment">        Person.prototype.__proto__ === Object.prototype</span></span><br><span class="line"><span class="comment">        Person.__proto__ === Function.prototype</span></span><br><span class="line"><span class="comment">        Function.__proto__ === Function.prototype</span></span><br><span class="line"><span class="comment">        Object.__proto__ === Function.prototype</span></span><br><span class="line"><span class="comment">        Function.prototype.__proto__ === Object.prototype</span></span><br><span class="line"><span class="comment">        Object.prototype.__proto__ === null</span></span><br><span class="line"><span class="comment">        */</span></span><br></pre></td></tr></table></figure><strong>原型链指向图</strong>：<br>？</li></ul><h2 id="三-判断数据类型"><a href="#三-判断数据类型" class="headerlink" title="三. 判断数据类型"></a>三. 判断数据类型</h2><p><strong>判断数据类型的方式</strong>：</p><ol><li><code>typeof</code><br> 语法：typeof(要测试的数据) 返回值：测试数据对应的数据类型 缺点：只能检测 基本数据类型和函数 注：检测函数时，得到的返回值为function<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> (<span class="number">12</span>)); <span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> (<span class="string">&#x27;null&#x27;</span>)); <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> (<span class="literal">null</span>)); <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> (<span class="literal">undefined</span>)); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> (<span class="literal">true</span>)); <span class="comment">// boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> ([])); <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> (&#123;&#125;)); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>使用typeof方式检测时各数据类型返回的值：</li></ol><ul><li>检查Undefined类型的值时，返回”undefined”。</li><li>检查Number类型的值时，返回”number”（包括NaN 和 Infinity）。</li><li>检查Boolean类型的值时，返回”boolean”。</li><li><strong>检查Null类型的值时，会返回”object”。</strong>(包括对象、数组)</li><li>检查String类型的值时，会返回”string”。</li><li>检查Symbol类型的值时，返回”symbol”</li><li>检查函数时，返回”function”</li></ul><ol start="2"><li><code>constructor</code><br> 语法：数据结构.constructor 返回值：该数据结构所属的构造函数 缺点：无法检测 undefined 和 null<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([].<span class="property">constructor</span>); <span class="comment">// ƒ Array() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125;.<span class="property">constructor</span>); <span class="comment">// ƒ Object() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;.<span class="property">constructor</span>); <span class="comment">// ƒ Function() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="number">1</span>).<span class="property">constructor</span>); <span class="comment">// ƒ Number() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="string">&#x27;zs&#x27;</span>).<span class="property">constructor</span>); <span class="comment">// ƒ String() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="literal">null</span>).<span class="property">constructor</span>); <span class="comment">// Uncaught TypeError: Cannot read properties of null (reading &#x27;constructor&#x27;)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="literal">undefined</span>).<span class="property">constructor</span>); <span class="comment">// Uncaught TypeError: Cannot read properties of undefined (reading &#x27;constructor&#x27;)</span></span><br></pre></td></tr></table></figure></li><li><code>instanceof</code><br> 语法：数据结构 instanceof 构造函数 返回值：true&#x2F;false 缺点：无法检测 undefined 和 null<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] <span class="keyword">instanceof</span> <span class="title class_">String</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a <span class="keyword">instanceof</span> <span class="title class_">Number</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><code>Object.prototype.toString.call()</code><br> 语法：Object.prototype.toString.call(要测试的数据) 返回值：’[Object 数据类型]’ 所有数据类型都可以检测<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">1</span>)); <span class="comment">// [object Number]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([])); <span class="comment">// [object Array]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;)); <span class="comment">// [object Object]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>)); <span class="comment">// [object Boolean]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">123</span>)); <span class="comment">// [object Number]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">apply</span>(<span class="number">123</span>)); <span class="comment">// [object Number]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">bind</span>(<span class="number">123</span>)()); <span class="comment">// [object Number]</span></span><br></pre></td></tr></table></figure><strong>注</strong>：不必一定用<code>call()</code>也可以使用<code>bind()()</code>或<code>apply()</code>，只要是立即执行即可。</li></ol>]]></content>
    
    
    <summary type="html">JS 原型与原型链以及判断数据类型方式</summary>
    
    
    
    <category term="前端" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://fanxing28.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS 继承</title>
    <link href="https://fanxing28.github.io/2023/12/14/%E5%89%8D%E7%AB%AF/JavaScript/JS%20%E7%BB%A7%E6%89%BF/"/>
    <id>https://fanxing28.github.io/2023/12/14/%E5%89%8D%E7%AB%AF/JavaScript/JS%20%E7%BB%A7%E6%89%BF/</id>
    <published>2023-12-14T14:42:00.000Z</published>
    <updated>2023-12-14T14:56:23.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-继承概念"><a href="#一-继承概念" class="headerlink" title="一. 继承概念"></a>一. 继承概念</h2><p>继承：一个构造函数中的实例使用另一个构造函数上的属性和方法</p><h3 id="1-为什么要学习继承"><a href="#1-为什么要学习继承" class="headerlink" title="1. 为什么要学习继承?"></a>1. 为什么要学习继承?</h3><p>写的构造函数, 定义了⼀个类型 (⼈类), 万⼀项⽬⾮常⼤, ⼜有了细化的多个类型 (⽼师, ⼯⼈, 学⽣) 学习继承, 可以让多个构造函数之间建⽴关联, 便于管理和复⽤</p><h3 id="2-什么是继承"><a href="#2-什么是继承" class="headerlink" title="2. 什么是继承?"></a>2. 什么是继承?</h3><p>继承: 从别⼈那⾥, 继承东⻄过来 (财产, 房产) 代码层⾯的继承: 继承⼀些属性构造的过程和⽅法</p><h2 id="二-原型继承"><a href="#二-原型继承" class="headerlink" title="二. 原型继承"></a>二. 原型继承</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="(1) 概念"></a>(1) 概念</h3><p><strong>原型继承</strong>：</p><ul><li>利用自定义原型的方法来实现继承关系</li><li>核心：子类的原型指向父类的实例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建父类的实例对象</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> <span class="title class_">Father</span>(<span class="string">&#x27;zs&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="comment">// 原型继承：子类的原型指向父类的实例</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = f;</span><br><span class="line"><span class="comment">// 创建子类的实例对象</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&quot;ls&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">sayHi</span>);</span><br><span class="line"><span class="comment">/*ƒ () &#123;</span></span><br><span class="line"><span class="comment">            console.log(this.age);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">s.<span class="title function_">sayHi</span>(); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-原型继承的原理"><a href="#2-原型继承的原理" class="headerlink" title="(2) 原型继承的原理"></a>(2) 原型继承的原理</h3><p>子类的原型(Son.prototype)指向了父类的实例（new Father()也就是f）<br>子类实例化的对象想要访问一个属性时：</p><ul><li>首先在自己身上寻找，</li><li>如果没有，沿着 <code>__proto__</code> 寻找，</li><li>子类的实例化对象的<code>s.__proto__</code>是所属的构造函数的原型 <code>Son.prototype == f</code></li></ul><h3 id="3-原型继承的优缺点"><a href="#3-原型继承的优缺点" class="headerlink" title="(3) 原型继承的优缺点"></a>(3) 原型继承的优缺点</h3><p>优点：可以实现继承父类的属性和方法<br>缺点：</p><ol><li>子类的原型被占用，之后往子类的原型上加属性和方法无效</li><li>继承下来的属性不在子类身上，在原型身上</li></ol><h2 id="三-借用继承"><a href="#三-借用继承" class="headerlink" title="三. 借用继承"></a>三. 借用继承</h2><h3 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="(1) 概念"></a>(1) 概念</h3><p>借用继承又叫：借用构造函数继承、call继承<br><strong>核心</strong>：把父类构造函数当做普通函数用，并利用call()、apply()、bind()()修改this的指向</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">sex, ...arg</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">    <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建子类的实例对象</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&quot;男&quot;</span>, <span class="string">&quot;zs&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s); <span class="comment">// Son&amp;nbsp;&#123;sex: &#x27;男&#x27;, name: &#x27;zs&#x27;, age: 20&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">sayHi</span>);</span><br></pre></td></tr></table></figure><blockquote><p><strong>分析</strong>：</p></blockquote><p>Father不和new连用，就是一个普通函数 普通函数调用，this指向window, 希望Son调用的时候，既使用Father里面的内容，同时希望Father里面的内容改成自己的，也就是说，希望使用的时候，this指向自己的this 希望修改Father普通函数的this指向 <code>call apply bind</code>都可以实现，只要注意参数和调用方式就可以了</p><h3 id="2-优缺点"><a href="#2-优缺点" class="headerlink" title="(2) 优缺点"></a>(2) 优缺点</h3><p>优点：</p><ol><li>可以把属性继承在自己身上</li><li>有自己的原型<br>缺点：只能继承父类的属性，不能继承原型的方法</li></ol><h2 id="四-组合继承"><a href="#四-组合继承" class="headerlink" title="四. 组合继承"></a>四. 组合继承</h2><h3 id="1-概念-2"><a href="#1-概念-2" class="headerlink" title="(1) 概念"></a>(1) 概念</h3><p>把原型继承和借用继承组合在一起</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">sex, ...arg</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">    <span class="comment">// 借用继承</span></span><br><span class="line">    <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型继承</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&quot;女&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s); <span class="comment">// Son&amp;nbsp;&#123;sex: &#x27;女&#x27;, name: &#x27;ls&#x27;, age: 20&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">sayHi</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        ƒ () &#123;</span></span><br><span class="line"><span class="comment">            console.log(this.age);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br></pre></td></tr></table></figure><h3 id="2-优缺点-1"><a href="#2-优缺点-1" class="headerlink" title="(2) 优缺点"></a>(2) 优缺点</h3><p>优点：</p><ol><li>可以继承属性和方法</li><li>继承的属性在自己身上<br>缺点：原型上存在一套属性</li></ol><h2 id="五-拷贝继承"><a href="#五-拷贝继承" class="headerlink" title="五. 拷贝继承"></a>五. 拷贝继承</h2><h3 id="1-概念-3"><a href="#1-概念-3" class="headerlink" title="(1) 概念"></a>(1) 概念</h3><p><strong>拷贝继承</strong>：把父类身上的所有内容复制一份放在子类的原型上<br>实现：利用 for…in 循环遍历对象<br><strong>in 关键字的作用</strong>：</p><blockquote><p>判断字符串是不是对象上的一个属性 返回值：true&#x2F;false 特点：不只是对象本身，原型上的也能访问到</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> obj); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;age&#x27;</span> <span class="keyword">in</span> obj); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> <span class="title class_">Father</span>(<span class="string">&#x27;tom&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> f); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;age&#x27;</span> <span class="keyword">in</span> f); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sayHi&#x27;</span> <span class="keyword">in</span> f); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="2-hasOwnProperty-方法"><a href="#2-hasOwnProperty-方法" class="headerlink" title="(2) hasOwnProperty() 方法"></a>(2) hasOwnProperty() 方法</h3><p>作用：判断某个属性是否在某个对象上<br>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;属性名&#x27;</span>)</span><br></pre></td></tr></table></figure><p>返回值：true&#x2F;false</p><ul><li>true 表示该属性在该对象上</li><li>false 表示不在<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> <span class="title class_">Father</span>(<span class="string">&#x27;tom&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;name&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;age&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;sayHi&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-拷贝继承案例"><a href="#3-拷贝继承案例" class="headerlink" title="(3) 拷贝继承案例"></a>(3) 拷贝继承案例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">sex, ...arg</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">    <span class="keyword">const</span> f = <span class="keyword">new</span> <span class="title class_">Father</span>(...arg);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> f) &#123;</span><br><span class="line">        <span class="comment">// 拷贝继承 把所有内容复制一份放在子类的原型上</span></span><br><span class="line">        <span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>[k] = f[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&quot;男&quot;</span>, <span class="string">&quot;zs&quot;</span>, <span class="number">22</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br></pre></td></tr></table></figure><h2 id="六-类继承（ES6）"><a href="#六-类继承（ES6）" class="headerlink" title="六. 类继承（ES6）"></a>六. 类继承（ES6）</h2><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">// 必须先写一个super() 相当于借用继承中把父类的方法用call在子类中执行一次</span></span><br><span class="line">        <span class="variable language_">super</span>()</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            super 关键字用于访问和调用一个对象的父对象上的函数。</span></span><br><span class="line"><span class="comment">            在构造函数中使用时，super关键字将单独出现，并且必须在使用 this 关键字之前使用。super 关键字也可以用来调用父对象上的函数。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：ES6的类可以继承ES5的构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 用构造函数实现父类</span></span><br><span class="line"><span class="comment">    function Father(name, age) &#123;</span></span><br><span class="line"><span class="comment">        this.name = name</span></span><br><span class="line"><span class="comment">        this.age = age</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    Father.prototype.sayHi = function () &#123;</span></span><br><span class="line"><span class="comment">        console.log(this.age);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    Father.prototype.sayHello = function () &#123;</span></span><br><span class="line"><span class="comment">        console.log(&quot;Hello&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Father</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">sex, ...arg</span>) &#123;</span><br><span class="line">        <span class="comment">// 等同于借用继承中，把父类的函数放在子类中在执行一次的操作</span></span><br><span class="line">        <span class="variable language_">super</span>(...arg);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">sing</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&quot;女&quot;</span>, <span class="string">&quot;tom&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s); <span class="comment">// Son&amp;nbsp;&#123;name: &#x27;tom&#x27;, age: 20, sex: &#x27;女&#x27;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">sayHi</span>);</span><br><span class="line">s.<span class="title function_">sayHi</span>(); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><h2 id="七-私有属性和方法"><a href="#七-私有属性和方法" class="headerlink" title="七. 私有属性和方法"></a>七. 私有属性和方法</h2><p>在继承中，父类中的部分方法和属性不希望子类继承<br><strong>静态语法</strong>：static 方法</p><ul><li>静态：书写在类自己身上，专门给自己使用，不可以被子类继承</li><li>动态：书写在原型上，可以被子类继承<br><strong>静态方法注意点</strong>：</li><li>静态方法只能由类进行调用</li><li>实例方法只能由实例对象进行调用</li><li>静态方法名和实例方法名<strong>允许重名</strong>，因为类内部的静态方法的调用者只能为类，实例方法的调用者只能为实例对象，不会在调用时造成歧义<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">        // 用构造函数实现父类</span></span><br><span class="line"><span class="comment">        function Father(name, age) &#123;</span></span><br><span class="line"><span class="comment">            this.name = name</span></span><br><span class="line"><span class="comment">            this.age = age</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        Father.prototype.sayHi = function () &#123;</span></span><br><span class="line"><span class="comment">            console.log(this.age);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        // ES5静态方法</span></span><br><span class="line"><span class="comment">        Father.sayHello = function () &#123;</span></span><br><span class="line"><span class="comment">            console.log(&#x27;Hello&#x27;);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Father</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">sex, ...arg</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(...arg)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sex</span> = sex</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;tom&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s); <span class="comment">// Son&amp;nbsp;&#123;name: &#x27;tom&#x27;, age: 18, sex: &#x27;男&#x27;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">sayHi</span>);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">继承：一个构造函数中的实例使用另一个构造函数上的属性和方法</summary>
    
    
    
    <category term="前端" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://fanxing28.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS 事件轮询机制</title>
    <link href="https://fanxing28.github.io/2023/12/14/%E5%89%8D%E7%AB%AF/JavaScript/JS%20%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6/"/>
    <id>https://fanxing28.github.io/2023/12/14/%E5%89%8D%E7%AB%AF/JavaScript/JS%20%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6/</id>
    <published>2023-12-14T14:41:00.000Z</published>
    <updated>2023-12-14T14:56:23.664Z</updated>
    
    <content type="html"><![CDATA[<p>事件轮询 (客户端)<br>开始轮询时间：从开始执行代码的时候就开始执行轮询<br><strong>规则</strong>：</p><ol><li>从第一个宏任务开始（一般是整个JavaScript代码段）</li><li>每执行完一个宏任务，清空一次微任务队列里面的所有内容</li><li>然后再执行一个宏任务</li><li>往复执行以上操作，直到所有队列任务都清空结束<br><strong>关键词</strong>：</li></ol><ul><li>单线程：JS是一个单线程的代码执行机制，如果逐行执行代码, 会阻塞代码执行</li><li>调用栈：用来执行代码的空间 （栈: 后进先出）</li><li>队列：存放异步任务 （队列: 先进先出）</li><li>宏任务队列：JS整块代码(script)、setTimeout、setInterval…</li><li>微任务队列：Promise.then…<br>?<br><strong>案例</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>)</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">7</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="title function_">resolve</span>()</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">8</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">9</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">10</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">11</span>)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">12</span>)</span><br><span class="line"><span class="comment">// 输出的顺序：1 3 9 12 4 10 2 11 5 6 8 7</span></span><br></pre></td></tr></table></figure><strong>上述案例代码分析</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出的顺序：1 3 9 12 4 10 2 11 5 6 8 7</span></span><br><span class="line"><span class="comment">// 第一次执行宏任务（整个JavaScript代码段）：</span></span><br><span class="line">  第<span class="number">1</span>行 <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>) 同步代码          =&gt; 直接执行，输出<span class="number">1</span></span><br><span class="line">  第<span class="number">3</span>-<span class="number">5</span>行 =&gt; 第一个定时器（异步代码）   =&gt; 放入<span class="variable constant_">WEBAPI</span>中等待分配（分配到宏任务中）</span><br><span class="line">  第<span class="number">7</span>-<span class="number">10</span>行 =&gt; 同步代码                 =&gt; 直接执行 ，输出<span class="number">3</span></span><br><span class="line">  第<span class="number">10</span>-<span class="number">12</span>行 =&gt; 第一个 <span class="keyword">new</span> <span class="title class_">Promise</span>().<span class="title function_">then</span>() (异步代码) =&gt; 放入<span class="variable constant_">WEBAPI</span>中等待分配（分配到微任务中）</span><br><span class="line">  第<span class="number">14</span>-<span class="number">25</span>行 =&gt; 第二个定时器（异步代码） =&gt; 放入<span class="variable constant_">WEBAPI</span>中等待分配（分配到宏任务中）</span><br><span class="line">  第<span class="number">27</span>-<span class="number">30</span>行 =&gt; 同步代码                =&gt; 直接执行 ，输出<span class="number">9</span></span><br><span class="line">  第<span class="number">30</span>-<span class="number">35</span>行 =&gt; 第二个 <span class="keyword">new</span> <span class="title class_">Promise</span>().<span class="title function_">then</span>()（异步代码）=&gt; 放入<span class="variable constant_">WEBAPI</span>中等待分配（分配到微任务中）</span><br><span class="line">  第<span class="number">37</span>行    =&gt; 同步代码                =&gt; 直接执行，输出<span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    至此  输出 1,3,9,12 </span></span><br><span class="line"><span class="comment">    宏任务中：第一个定时器（0ms）、第二个定时器（500ms）</span></span><br><span class="line"><span class="comment">    微任务中：第一个 new Promise().then()、第二个 new Promise().then()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 第一次宏任务结束，开始执行第一次微任务队列</span></span><br><span class="line"></span><br><span class="line">  第<span class="number">10</span>-<span class="number">12</span>行 =&gt; 第一个 <span class="keyword">new</span> <span class="title class_">Promise</span>().<span class="title function_">then</span>(),输出<span class="number">4</span></span><br><span class="line">  第<span class="number">30</span>-<span class="number">35</span>行 =&gt; 第二个 <span class="keyword">new</span> <span class="title class_">Promise</span>().<span class="title function_">then</span>(),输出<span class="number">10</span> </span><br><span class="line">  在第<span class="number">32</span>-<span class="number">35</span>行 =&gt; 第三个定时器  =&gt; 放入<span class="variable constant_">WEBAPI</span>中等待分配（分配到宏任务中）</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    至此  输出 1,3,9,12,4,10</span></span><br><span class="line"><span class="comment">    宏任务中：第一个定时器（0ms）、第三个定时器（0ms）、第二个定时器（500ms）</span></span><br><span class="line"><span class="comment">    微任务中：无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 第一次微任务队列所有微任务结束，开始执行第二次宏任务</span></span><br><span class="line"></span><br><span class="line">  第<span class="number">3</span>-<span class="number">5</span>行第一个定时器（0ms）,输出<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    至此  输出 1,3,9,12,4,10,2</span></span><br><span class="line"><span class="comment">    宏任务中：第三个定时器（0ms）、第二个定时器（500ms）</span></span><br><span class="line"><span class="comment">    微任务中：无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 此时微任务队列没有等待队列，开始执行第三次宏任务</span></span><br><span class="line"></span><br><span class="line">  第<span class="number">32</span>-<span class="number">35</span>行第三个定时器（0ms）,输出<span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    至此  输出 1,3,9,12,4,10,2,11</span></span><br><span class="line"><span class="comment">    宏任务中：第二个定时器（500ms）</span></span><br><span class="line"><span class="comment">    微任务中：无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 此时微任务队列没有等待队列，开始执行第四次宏任务</span></span><br><span class="line"></span><br><span class="line">  第<span class="number">14</span>-<span class="number">25</span>行第二个定时器(<span class="attr">time</span>:500ms)</span><br><span class="line">  第<span class="number">15</span>行 （同步代码） =&gt; 直接执行,输出<span class="number">5</span></span><br><span class="line">  第<span class="number">17</span>行 （同步代码） =&gt; 直接执行,输出<span class="number">6</span></span><br><span class="line">  第<span class="number">18</span>行 =&gt; 第五个定时器（异步代码） =&gt; 放入<span class="variable constant_">WEBAPI</span>中等待分配（分配到宏任务中）</span><br><span class="line">  第<span class="number">19</span>行 =&gt; 第三个 <span class="keyword">new</span> <span class="title class_">Promise</span>().<span class="title function_">then</span>()（异步代码） =&gt; 放入<span class="variable constant_">WEBAPI</span>中等待分配（分配到微任务中）</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    至此  输出 1,3,9,12,4,10,2,11,5,6</span></span><br><span class="line"><span class="comment">    宏任务中：第五个定时器（500ms）</span></span><br><span class="line"><span class="comment">    微任务中：第三个 new Promise().then()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 第四次宏任务结束，执行微任务队列</span></span><br><span class="line"></span><br><span class="line">  第<span class="number">19</span>行 =&gt; 第三个 <span class="keyword">new</span> <span class="title class_">Promise</span>().<span class="title function_">then</span>(),输出<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    至此  输出 1,3,9,12,4,10,2,11,5,6,8</span></span><br><span class="line"><span class="comment">    宏任务中：第五个定时器（500ms）</span></span><br><span class="line"><span class="comment">    微任务中：无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 微任务队列结束，执行第五次宏任务</span></span><br><span class="line"></span><br><span class="line">  第<span class="number">18</span>行 =&gt; 第五个定时器（500ms）,输出<span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    至此  输出 1,3,9,12,4,10,2,11,5,6,8,7</span></span><br><span class="line"><span class="comment">    宏任务中：无</span></span><br><span class="line"><span class="comment">    微任务中：无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终输出结果为：1,3,9,12,4,10,2,11,5,6,8,7</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">JS 事件轮询机制</summary>
    
    
    
    <category term="前端" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://fanxing28.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS 设计模式</title>
    <link href="https://fanxing28.github.io/2023/12/14/%E5%89%8D%E7%AB%AF/JavaScript/JS%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://fanxing28.github.io/2023/12/14/%E5%89%8D%E7%AB%AF/JavaScript/JS%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-12-14T14:36:00.000Z</published>
    <updated>2023-12-14T14:56:23.664Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式是我们在解决问题的时候针对特定问题给出的简洁而优化的处理方案。</p><p>设计模式（Design Pattern）是一套被反复使用，多人知晓，经过分类编目的优秀代码设计经验的总结。使用设计模式是为了重用代码，使代码更容易理解并保证代码的可靠性。使用设计模式对于自己，对他人，对系统都是有利的。设计模式使代码编制更加工程化，是软件工程的基石。</p><h2 id="一-单例模式"><a href="#一-单例模式" class="headerlink" title="一. 单例模式"></a>一. 单例模式</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="(1) 概念"></a>(1) 概念</h3><p>单例模式的<strong>定义</strong>是：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><blockquote><p>简言之，不管你使用构造函数实例化多少回，都是同一个对象。</p></blockquote><p><strong>单例模式核心</strong>：<br>在实例化一个类的时候：</p><ul><li>先判断，之前有没有实例化过</li><li>如果有，就用之前的</li><li>如果没有，就实例化一个新的<br><strong>单例模式优点</strong>：创建对象和管理单例的职责被分布在两个不同的方法中</li></ul><h3 id="2-场景"><a href="#2-场景" class="headerlink" title="(2) 场景"></a>(2) 场景</h3><p>单例模式是一种常用的模式，有一些对象我们往往只需要一个，比如<strong>线程池、全局缓存、浏览器中的 window</strong> 对象等。<br>在 JavaScript 开发中，单例模式的用途同样非常广泛。试想一下，当我们单击登录按钮的时候，页面中会出现一个登录浮窗，而这个<strong>登录浮窗</strong>是唯一的，无论单击多少次登录按钮，这个浮窗都只会被创建一次，那么这个登录浮窗就适合用单例模式来创建。</p><h3 id="3-案例：书写一个弹窗"><a href="#3-案例：书写一个弹窗" class="headerlink" title="(3) 案例：书写一个弹窗"></a>(3) 案例：书写一个弹窗</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*分析：</span></span><br><span class="line"><span class="comment">找到一个变量，初始化的时候是null </span></span><br><span class="line"><span class="comment">第一次实例化后，给这个变量赋值</span></span><br><span class="line"><span class="comment">第二次想要实例化的时候，先去看看这个变量有没有值，如果有，就用之前的</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个弹窗的构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dialog</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">title</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">title</span> = title</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">div</span> = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">div</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;pink&#x27;</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(<span class="variable language_">this</span>.<span class="property">div</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">changeTile</span>(<span class="params">title</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">title</span> = title</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">div</span>.<span class="property">innerHTML</span> = <span class="variable language_">this</span>.<span class="property">title</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单例模式代码</span></span><br><span class="line"><span class="comment">// 为了避免instance这个变量污染 改成闭包</span></span><br><span class="line"><span class="keyword">const</span> singleton = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 提前设置一个变量，用来记录该构造函数有没有实例化过</span></span><br><span class="line">    <span class="keyword">let</span> instance = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">title</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断构造函数有没有实例化过 </span></span><br><span class="line">        <span class="comment">// 没有实例化过</span></span><br><span class="line">        <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Dialog</span>(title)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有，就返回这个实例化对象</span></span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// 创建弹窗对象</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="title function_">singleton</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">res.<span class="title function_">changeTile</span>(<span class="string">&#x27;小花&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次创建弹窗对象</span></span><br><span class="line"><span class="keyword">const</span> res1 = <span class="title function_">singleton</span>(<span class="string">&#x27;你好&#x27;</span>)</span><br><span class="line">res1.<span class="title function_">changeTile</span>(<span class="string">&#x27;你好&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res1); <span class="comment">// Dialog&amp;nbsp;&#123;title: &#x27;你好&#x27;, div: div&#125;</span></span><br></pre></td></tr></table></figure><h2 id="二-策略模式"><a href="#二-策略模式" class="headerlink" title="二. 策略模式"></a>二. 策略模式</h2><h3 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="(1) 概念"></a>(1) 概念</h3><p>策略模式的<strong>定义</strong>是：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。<br>策略模式的<strong>目的</strong>是：将算法的使用与算法的实现分离开来。<br>一个基于策略模式的程序至少由两部分组成。第一个部分是一组<strong>策略类</strong>，策略类封装了具体 的算法，并负责具体的计算过程。 第二个部分是<strong>环境类Context</strong>，Context 接受客户的请求，随后 把请求委托给某一个策略类。要做到这点，说明 Context中要维持对某个策略对象的引用。</p><h3 id="2-场景-1"><a href="#2-场景-1" class="headerlink" title="(2) 场景"></a>(2) 场景</h3><p>从定义上看，策略模式就是用来封装算法的。但如果把策略模式仅仅用来封装算法，未免有一点大材小用。在实际开发中，我们通常会把算法的含义扩散开来，使策略模式也可以用来封装 一系列的“业务规则”。只要这些业务规则指向的目标一致，并且可以被替换使用，我们就可以 用策略模式来封装它们。</p><h3 id="3-案例"><a href="#3-案例" class="headerlink" title="(3) 案例"></a>(3) 案例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 例子  已知一个商品总价 500</span></span><br><span class="line"><span class="comment">       根据折扣计算实际价格</span></span><br><span class="line"><span class="comment">       例如：80%  70%  1000-300   800-50</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过闭包的形式计算折扣</span></span><br><span class="line"><span class="keyword">const</span> calcDiscount = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> priceList = &#123;</span><br><span class="line">        <span class="string">&quot;80%&quot;</span>: <span class="keyword">function</span> (<span class="params">total</span>) &#123; <span class="keyword">return</span> (total * <span class="number">0.8</span>).<span class="title function_">toFixed</span>(<span class="number">2</span>) &#125;,</span><br><span class="line">        <span class="string">&quot;70%&quot;</span>: <span class="keyword">function</span> (<span class="params">total</span>) &#123; <span class="keyword">return</span> (total * <span class="number">0.7</span>).<span class="title function_">toFixed</span>(<span class="number">2</span>) &#125;,</span><br><span class="line">        <span class="string">&quot;50%&quot;</span>: <span class="keyword">function</span> (<span class="params">total</span>) &#123; <span class="keyword">return</span> (total * <span class="number">0.5</span>).<span class="title function_">toFixed</span>(<span class="number">2</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params">total, type</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!priceList[type]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;折扣错误&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 反之折扣正确,返回计算后的价格</span></span><br><span class="line">        <span class="keyword">return</span> priceList[type](total);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接下来根据需求定义一系列的算法</span></span><br><span class="line">    <span class="comment">// 添加折扣</span></span><br><span class="line">    inner.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params">type, fn</span>) &#123;</span><br><span class="line">        priceList[type] = fn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除折扣</span></span><br><span class="line">    inner.<span class="property">remove</span> = <span class="keyword">function</span> (<span class="params">type</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> priceList[type];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改折扣</span></span><br><span class="line">    inner.<span class="property">change</span> = <span class="keyword">function</span> (<span class="params">type, fn</span>) &#123;</span><br><span class="line">        priceList[type] = fn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看折扣</span></span><br><span class="line">    inner.<span class="property">look</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> priceList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inner;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试算法</span></span><br><span class="line"><span class="comment">// 1.计算价格</span></span><br><span class="line"><span class="comment">// const res = calcDiscount(1400, &quot;80%&quot;);</span></span><br><span class="line"><span class="comment">// console.log(res); // 1120.00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.添加折扣</span></span><br><span class="line"><span class="comment">// calcDiscount.add(&quot;40%&quot;, function (total) &#123; return (total * 0.4).toFixed(2) &#125;);</span></span><br><span class="line"><span class="comment">// const res = calcDiscount(1500, &quot;40%&quot;)</span></span><br><span class="line"><span class="comment">// console.log(res); // 600</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.删除折扣</span></span><br><span class="line"><span class="comment">// calcDiscount.remove(&quot;80%&quot;);</span></span><br><span class="line"><span class="comment">// const res = calcDiscount(1200, &quot;80%&quot;);</span></span><br><span class="line"><span class="comment">// console.log(res); // 折扣错误  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.修改折扣</span></span><br><span class="line">calcDiscount.<span class="title function_">change</span>(<span class="string">&quot;70%&quot;</span>, <span class="keyword">function</span> (<span class="params">total</span>) &#123; <span class="keyword">return</span> (total * <span class="number">0.4</span>).<span class="title function_">toFixed</span>(<span class="number">2</span>) &#125;);</span><br><span class="line"><span class="keyword">const</span> res = <span class="title function_">calcDiscount</span>(<span class="number">1200</span>, <span class="string">&quot;70%&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// 480.00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.查看折扣</span></span><br><span class="line"><span class="comment">// console.log(calcDiscount.look()); // &#123;80%: ƒ, 70%: ƒ, 50%: ƒ&#125;</span></span><br></pre></td></tr></table></figure><h3 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="(4) 优缺点"></a>(4) 优缺点</h3><p><strong>优点</strong>：</p><ul><li>策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句。</li><li>策略模式提供了对开放—封闭原则的完美支持，将算法封装在独立的策略中，使得它们易于切换，易于理解，易于扩展。</li><li>策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作。</li><li>在策略模式中利用组合和委托来让环境类拥有执行算法的能力，这也是继承的一种更轻便的替代方案。<br><strong>缺点</strong>：</li><li>增加许多策略类或者策略对象，但实际上这比把它们负责的 逻辑堆砌在环境类中要好。</li><li>要使用策略模式，必须了解所有的策略，必须了解各个策略之间的不同点， 这样才能选择一个合适的策略。</li></ul><h2 id="三-发布-订阅模式"><a href="#三-发布-订阅模式" class="headerlink" title="三. 发布-订阅模式"></a>三. 发布-订阅模式</h2><h3 id="1-什么是发布-订阅模式"><a href="#1-什么是发布-订阅模式" class="headerlink" title="(1) 什么是发布-订阅模式"></a>(1) 什么是发布-订阅模式</h3><p>通常也被叫做观察者模式或消息模式</p><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p><strong>发布-订阅模式</strong>其实是一种对象间一对多的依赖关系，当一个对象的状态发送改变时，所有依赖于它的对象都将得到状态改变的通知。<br>订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Event Channel），当发布者（Publisher）发布该事件（Publish Event）到调度中心，也就是该事件触发时，由调度中心统一调度（Fire Event）订阅者注册到调度中心的处理代码。</p><h4 id="2-例子"><a href="#2-例子" class="headerlink" title="2. 例子"></a>2. 例子</h4><p><strong>例子1</strong>：比如我们很喜欢看某个公众号号的文章，但是我们不知道什么时候发布新文章，要不定时的去翻阅；这时候，我们可以关注该公众号，当有文章推送时，会有消息及时通知我们文章更新了。<br>上面一个看似简单的操作，其实是一个典型的发布订阅模式，公众号属于发布者，用户属于订阅者；用户将订阅公众号的事件注册到调度中心，公众号作为发布者，当有新文章发布时，公众号发布该事件到调度中心，调度中心会及时发消息告知用户。<br><strong>例子2</strong>：一个卖书的例子，当你去买书的时候，如果当时有你要买的书，可以直接买到当时当书店没有这本书的时候，你就需要先在书店预订，让老板等书到了通知你，而如果你等待的时候突然又不想买了你可以告诉老板你不要了。<br>在上述案例中，老板就是发布者，买者就是订阅者，不想要了就是取消订阅。</p><h3 id="2-如何实现发布-订阅模式？"><a href="#2-如何实现发布-订阅模式？" class="headerlink" title="(2) 如何实现发布-订阅模式？"></a>(2) 如何实现发布-订阅模式？</h3><h4 id="1-实现思路"><a href="#1-实现思路" class="headerlink" title="1. 实现思路"></a>1. 实现思路</h4><ul><li>创建一个对象</li><li>在该对象上创建一个缓存列表（调度中心）</li><li>add方法用来把函数 fn 都加到缓存列表中（订阅者注册事件到调度中心）</li><li>emit 方法取到 arguments 里第一个当做 event，根据 event 值去执行对应缓存列表中的函数（发布者发布事件到调度中心，调度中心处理代码）</li><li>remove 方法可以根据 event 值取消订阅（取消订阅）</li></ul><h4 id="2-具体简单实现例子2：到书店买书"><a href="#2-具体简单实现例子2：到书店买书" class="headerlink" title="2. 具体简单实现例子2：到书店买书"></a>2. 具体简单实现例子2：到书店买书</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Subscribe</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 登记本：存放书籍和操作方法</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">message</span> = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加订阅消息</span></span><br><span class="line">    <span class="title function_">add</span>(<span class="params">type, fn</span>) &#123;</span><br><span class="line">        <span class="comment">// type:订阅的书籍</span></span><br><span class="line">        <span class="comment">// fn：书籍到货后的方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加前，判断登记本上是否已经存在这本书籍</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">message</span>[type]) &#123;</span><br><span class="line">            <span class="comment">// 如果不存在，设置一个空数组</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">message</span>[type] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果存在，不重复登记</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">message</span>[type].<span class="title function_">indexOf</span>(fn) !== -<span class="number">1</span>) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="comment">// 正常登记，添加对应的书籍数据</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">message</span>[type].<span class="title function_">push</span>(fn);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">message</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 所需的书籍到货，发布通知</span></span><br><span class="line">    <span class="title function_">emit</span>(<span class="params">type</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果还没有这本书籍</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">message</span>[type]) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="comment">// 如果书籍到货，通知所有想要这本书籍的人</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">message</span>[type].<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="title function_">item</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取消订阅</span></span><br><span class="line">    <span class="title function_">remove</span>(<span class="params">type, fn</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果没有对应的订阅消息</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">message</span>[type]) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="comment">// 取消该书籍所有的订阅消息</span></span><br><span class="line">        <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">message</span>[type];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取消对应的订阅消息</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">message</span>[type] = <span class="variable language_">this</span>.<span class="property">message</span>[type].<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item !== fn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置一个卖书的老板</span></span><br><span class="line"><span class="keyword">const</span> zs = <span class="keyword">new</span> <span class="title class_">Subscribe</span>();</span><br><span class="line"><span class="comment">// 进行操作</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;小王需要一本&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;小张需要一本&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 订阅</span></span><br><span class="line">zs.<span class="title function_">add</span>(<span class="string">&quot;西游记&quot;</span>, fn1); <span class="comment">// &#123;西游记: Array(1)&#125;</span></span><br><span class="line">zs.<span class="title function_">add</span>(<span class="string">&quot;西游记&quot;</span>, fn2); <span class="comment">// &#123;西游记: Array(2)&#125;</span></span><br><span class="line">zs.<span class="title function_">add</span>(<span class="string">&quot;三国演义&quot;</span>, fn2); <span class="comment">// &#123;西游记: Array(2), 三国演义: Array(1)&#125;</span></span><br><span class="line"><span class="comment">// 发布</span></span><br><span class="line">zs.<span class="title function_">emit</span>(<span class="string">&quot;西游记&quot;</span>); <span class="comment">// 小王需要一本 小张需要一本</span></span><br><span class="line">zs.<span class="title function_">emit</span>(<span class="string">&quot;红楼梦&quot;</span>);</span><br><span class="line"><span class="comment">// 取消订阅</span></span><br><span class="line">zs.<span class="title function_">remove</span>(<span class="string">&quot;西游记&quot;</span>, fn1); <span class="comment">// &#123;西游记: Array(1), 三国演义: Array(1)&#125;</span></span><br><span class="line">zs.<span class="title function_">remove</span>(<span class="string">&quot;红楼梦&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="(3) 优缺点"></a>(3) 优缺点</h3><ol><li><strong>优点</strong></li></ol><ul><li>对象之间解耦</li><li>异步编程中，可以更松耦合的代码编写</li></ul><ol start="2"><li><strong>缺点</strong></li></ol><ul><li>创建订阅者本身要消耗一定的时间和内存</li><li>虽然可以弱化对象之间的联系，多个发布者和订阅者嵌套一起的时候，程序难以跟踪维护</li></ul>]]></content>
    
    
    <summary type="html">设计模式（Design Pattern）是一套被反复使用，多人知晓，经过分类编目的优秀代码设计经验的总结。使用设计模式是为了重用代码，使代码更容易理解并保证代码的可靠性。使用设计模式对于自己，对他人，对系统都是有利的。设计模式使代码编制更加工程化，是软件工程的基石。</summary>
    
    
    
    <category term="前端" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://fanxing28.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS 数据劫持(代理)</title>
    <link href="https://fanxing28.github.io/2023/12/14/%E5%89%8D%E7%AB%AF/JavaScript/JS%20%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81(%E4%BB%A3%E7%90%86)/"/>
    <id>https://fanxing28.github.io/2023/12/14/%E5%89%8D%E7%AB%AF/JavaScript/JS%20%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81(%E4%BB%A3%E7%90%86)/</id>
    <published>2023-12-14T14:34:00.000Z</published>
    <updated>2023-12-14T14:56:23.664Z</updated>
    
    <content type="html"><![CDATA[<p>所谓数据代理（也叫数据劫持），指的是在访问或者修改对象的某个属性时，通过一段代码拦截这个行为，进行额外的操作或者修改返回结果。比较典型的是 <code>Object.defineProperty()</code> 和 ES2015 中新增的 <code>Proxy</code> 对象。而在前端框架中vue2.0使用的是<code>Object.defineProperty()</code>、vue3.0使用的是<code>Proxy</code>。当然今天主要讲述的JS和ES中的数据劫持，vue中的小编后续会安排上。</p><h2 id="一-Object-defineProperty"><a href="#一-Object-defineProperty" class="headerlink" title="一. Object.defineProperty()"></a>一. Object.defineProperty()</h2><p>语法：Object.defineProperty(数据, 属性名, {配置项})<br><strong>配置项</strong>：</p><ul><li>value：设置属性名对应的属性值</li><li>writable：设置的属性是否可以修改<blockquote><p>值：true&#x2F;false(默认)</p></blockquote></li><li>enumerable：设置的属性是否可以遍历<blockquote><p>值：true&#x2F;false (默认)</p></blockquote></li><li>configurable：设置的属性是否可以删除<blockquote><p>值：true&#x2F;false(默认)</p></blockquote></li><li>getter、setter：不允许和value, writable连用，连用会报错</li><li>get 获取的时候可以触发的方法</li><li>set 设置的时候可以触发的方法<br><strong>注</strong>：value、writable、enumerable、configurable可以单独使用也可以连用<br><strong>针对上述配置项的使用情况</strong>：<br><strong>(1) value</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;zs&quot;</span> &#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&quot;age&quot;</span>, &#123;</span><br><span class="line">    <span class="comment">// 设置属性名对应的属性值</span></span><br><span class="line">    <span class="attr">value</span>: <span class="number">20</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123;name: &#x27;zs&#x27;, age: 20&#125;</span></span><br><span class="line">obj.<span class="property">age</span> = <span class="number">30</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123;name: &#x27;zs&#x27;, age: 20&#125;</span></span><br></pre></td></tr></table></figure><strong>(2) writable</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;zs&quot;</span> &#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&quot;age&quot;</span>, &#123;</span><br><span class="line">    <span class="comment">// 设置的属性可以修改 </span></span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123; name: &#x27;zs&#x27;, age: undefined &#125;</span></span><br><span class="line">obj.<span class="property">age</span> = <span class="number">30</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123;name: &#x27;zs&#x27;, age: 20&#125;</span></span><br></pre></td></tr></table></figure><strong>(3) enumerable</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;zs&quot;</span> &#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&quot;age&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="comment">// 设置的属性可以遍历 </span></span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(k, obj[k]); <span class="comment">// name zs age 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>(4) configurable</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;zs&quot;</span> &#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&quot;age&quot;</span>, &#123;</span><br><span class="line">    <span class="comment">// 设置的属性可以删除  </span></span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">name</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123;age: undefined&#125;</span></span><br></pre></td></tr></table></figure><strong>(5) get set定义属性</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;zs&quot;</span> &#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&quot;age&quot;</span>, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>; <span class="comment">// 当我们设置一个返回值的时候，就表示该属性被设置了值</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="comment">// 可以监听到设置的值</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(val); <span class="comment">// 19</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">obj.<span class="property">age</span> = <span class="number">19</span>; <span class="comment">// 设置的时候，会触发 set方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">age</span>); <span class="comment">// 20 (获取的时候， 会触发 get方法)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br></pre></td></tr></table></figure></li></ul><h2 id="二-数据劫持"><a href="#二-数据劫持" class="headerlink" title="二. 数据劫持"></a>二. 数据劫持</h2><p>当访问或者修改对象的某个属性的时候，通过 getter setter 拦截这个行为，进行额外的操作 将原始的数据复制一份，通过复制的数据操作原始数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;box&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;ipt1&quot;&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;ipt2&quot;&gt;</span><br><span class="line">&lt;!-- 分割线 --&gt; </span><br><span class="line">// 原始数据</span><br><span class="line">const obj = &#123;</span><br><span class="line">    name: &#x27;zs&#x27;,</span><br><span class="line">    age: 20</span><br><span class="line">&#125;</span><br><span class="line">// 目标数据</span><br><span class="line">const target = &#123;&#125;</span><br><span class="line">// 通过数据劫持的方法，把原始数据复制到目标中</span><br><span class="line">Object.defineProperty(target, &#x27;name&#x27;, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">        return obj.name</span><br><span class="line">    &#125;,</span><br><span class="line">    set(val) &#123;</span><br><span class="line">        obj.name = val</span><br><span class="line">        box.innerHTML = `你好， 我叫$&#123;target.name&#125; , 我今年$&#123;target.age&#125;`</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">Object.defineProperty(target, &#x27;age&#x27;, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">        return obj.age</span><br><span class="line">    &#125;,</span><br><span class="line">    set(val) &#123;</span><br><span class="line">        obj.age = val</span><br><span class="line">        box.innerHTML = `你好， 我叫$&#123;target.name&#125; , 我今年$&#123;target.age&#125;`</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">box.innerHTML = `你好， 我叫$&#123;target.name&#125; , 我今年$&#123;target.age&#125;`</span><br><span class="line">ipt1.onchange = function () &#123;</span><br><span class="line">    target.name = this.value</span><br><span class="line">&#125;</span><br><span class="line">ipt2.onchange = function () &#123;</span><br><span class="line">    target.age = this.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-封装函数实现数据劫持"><a href="#三-封装函数实现数据劫持" class="headerlink" title="三. 封装函数实现数据劫持"></a>三. 封装函数实现数据劫持</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;ipt1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;ipt2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 原始对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> obj = &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">age</span>: <span class="number">20</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 进行封装函数实现数据劫持</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">encapsulation</span>(<span class="params">obj, cb</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 目标对象</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 通过数据劫持的方法，把原始数据复制到目标中</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> target = &#123;&#125;;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 遍历原始对象，拿到对象中的每一个值</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> obj) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, k, &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">get</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">return</span> obj[k];</span></span><br><span class="line"><span class="language-javascript">                &#125;,</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">set</span>(<span class="params">val</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    obj[k] = val;</span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">cb</span>(target);</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">cb</span>(target);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> target;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 调用封装函数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> app = <span class="title function_">encapsulation</span>(obj, <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        box.<span class="property">innerHTML</span> = <span class="string">`你好， 我叫<span class="subst">$&#123;target.name&#125;</span> , 我今年<span class="subst">$&#123;target.age&#125;</span>`</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 获取input框中输入的值</span></span></span><br><span class="line"><span class="language-javascript">    ipt1.<span class="property">onchange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        app.<span class="property">name</span> = <span class="variable language_">this</span>.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    ipt2.<span class="property">onchange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        app.<span class="property">age</span> = <span class="variable language_">this</span>.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>效果图</strong>：<br>?</p><h2 id="四-数据代理-Proxy"><a href="#四-数据代理-Proxy" class="headerlink" title="四. 数据代理(Proxy)"></a>四. 数据代理(Proxy)</h2><p>在数据劫持这个问题上，<code>Proxy</code> 可以被认为是 <code>Object.defineProperty()</code> 的升级版。外界对某个对象的访问，都必须经过这层拦截。因此它是针对 <strong>整个对象</strong>，而不是 <strong>对象的某个属性</strong>，所以也就不需要对 <code>keys</code> 进行遍历。<br><strong>Proxy</strong> 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。<br><strong>语法</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li>target<blockquote><p>要使用 <code>Proxy</code> 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</p></blockquote></li><li>handler<blockquote><p>一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 <code>p</code> 的行为。</p></blockquote></li></ul><p><strong>简单的数据代理案例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开始代理</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="comment">// 访问数据的时候 会触发</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> target[property];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 设置数据的时候会触发</span></span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, property, val</span>) &#123;</span><br><span class="line">        <span class="comment">// target 就是要代理的目标对象</span></span><br><span class="line">        <span class="comment">// property 就是要修改的属性</span></span><br><span class="line">        <span class="comment">// val 修改的属性值</span></span><br><span class="line">        target[property] = val;</span><br><span class="line">        <span class="comment">// 必须写，简单代理必须返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">res.<span class="property">name</span> = <span class="string">&#x27;jerry&#x27;</span>;</span><br><span class="line"><span class="comment">// 给对象新添加一个数据</span></span><br><span class="line">res.<span class="property">sex</span> = <span class="string">&#x27;女&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;原始数据&#x27;</span>, obj); <span class="comment">// 原始数据 &#123;name: &#x27;jerry&#x27;, age: 18, sex: &#x27;女&#x27;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;代理结果&#x27;</span>, res); <span class="comment">// 代理结果 Proxy&amp;nbsp;&#123;name: &#x27;jerry&#x27;, age: 18, sex: &#x27;女&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="五-Proxy和Object-defineProperty的区别"><a href="#五-Proxy和Object-defineProperty的区别" class="headerlink" title="五. Proxy和Object.defineProperty的区别"></a>五. Proxy和Object.defineProperty的区别</h2><ol><li>Proxy是对整个对象的代理，而Object.defineProperty只能代理某个属性。</li><li>对象上新增属性，Proxy可以监听到，Object.defineProperty不能。</li><li>数组新增修改，Proxy可以监听到，Object.defineProperty不能。</li><li>若对象内部属性要全部递归代理，Proxy可以只在调用的时候递归，而Object.definePropery需要一次完成所有递归，性能比Proxy差。</li><li>Proxy不兼容IE，Object.defineProperty不兼容IE8及以下</li><li>Proxy使用上比Object.defineProperty方便多。</li></ol>]]></content>
    
    
    <summary type="html">所谓数据代理（也叫数据劫持），指的是在访问或者修改对象的某个属性时，通过一段代码拦截这个行为，进行额外的操作或者修改返回结果。</summary>
    
    
    
    <category term="前端" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://fanxing28.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS 深浅拷贝及闭包</title>
    <link href="https://fanxing28.github.io/2023/12/14/%E5%89%8D%E7%AB%AF/JavaScript/JS%20%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8F%8A%E9%97%AD%E5%8C%85/"/>
    <id>https://fanxing28.github.io/2023/12/14/%E5%89%8D%E7%AB%AF/JavaScript/JS%20%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8F%8A%E9%97%AD%E5%8C%85/</id>
    <published>2023-12-14T14:30:00.000Z</published>
    <updated>2023-12-14T14:58:36.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-深浅拷贝"><a href="#一-深浅拷贝" class="headerlink" title="一. 深浅拷贝"></a>一. 深浅拷贝</h2><h3 id="1-赋值"><a href="#1-赋值" class="headerlink" title="(1) 赋值"></a>(1) 赋值</h3><p>赋值：把一个数据结构的地址复制一份给另一个变量<br><strong>值传递和引用传递</strong></p><ul><li>基本数据类型：值传递</li><li>引用类型：引用传递<br>值传递就是将基本数据类型的值复制一份，就是简单地赋值操作。 使用值传递，修改接收方的变量值，不会影响原传递变量<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">b++;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,b); <span class="comment">// 10 11(值传递后，修改接收的变量值，不会影响原传递变量)</span></span><br></pre></td></tr></table></figure>引用传递是将地址赋值给接收的变量。 使用引用传递，修改接收方的变量值，会将原传递变量一同修改。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> brr = arr;</span><br><span class="line">brr.<span class="title function_">push</span>(<span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr, brr); <span class="comment">// (5)&amp;nbsp;[1, 3, 4, 5, 2] (5)&amp;nbsp;[1, 3, 4, 5, 2]</span></span><br></pre></td></tr></table></figure><blockquote><p>原因：arr将地址赋值给brr，使得brr和arr指向的是相同的地址，然后引用类型通过地址去找对应的值，所以最终arr的值会和brr的值相同，一同被修改。</p></blockquote></li></ul><p>为什么需要深浅拷贝 &#x3D;&#x3D;&gt; 它的产生就是来解决上述引用传递中产生的问题的（使用引用传递，修改接收方的变量值，会将原传递变量一同修改）。</p><h3 id="2-浅拷贝"><a href="#2-浅拷贝" class="headerlink" title="(2) 浅拷贝"></a>(2) 浅拷贝</h3><p>浅拷贝：<strong>将对象里面的值逐个赋值给另一个对象</strong>，但是如果是对象的嵌套，浅拷贝无法实现，必须使用深拷贝。</p><ul><li>浅拷贝仅支持一层拷贝赋值</li><li>深拷贝支持多层拷贝赋值<br>原始数据结构中的key</li><li>存储的是基本数据类型，可以拷贝</li><li>存储的是引用数据类型无法拷贝<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">info</span>: &#123; <span class="attr">sex</span>: <span class="string">&quot;男&quot;</span> &#125; &#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> obj1) &#123;</span><br><span class="line">    obj2[k] = obj1[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1, obj2); <span class="comment">// &#123;name: &#x27;zs&#x27;, age: 18, info: &#123;…&#125;&#125; &#123;name: &#x27;zs&#x27;, age: 18, info: &#123;…&#125;&#125;</span></span><br><span class="line">obj1.<span class="property">name</span> = <span class="string">&quot;ls&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1, obj2); <span class="comment">// &#123;name: &#x27;ls&#x27;, age: 18, info: &#123;…&#125;&#125; &#123;name: &#x27;zs&#x27;, age: 18, info: &#123;…&#125;&#125;</span></span><br><span class="line">obj1.<span class="property">info</span>.<span class="property">sex</span> = <span class="string">&quot;女&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1, obj2); <span class="comment">// 两个sex都改为女</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h4><p>语法：Object.assign(新对象,原始对象)<br>返回值：把原始对象内的数据浅拷贝一份放入到新对象中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">info</span>: &#123; <span class="attr">sex</span>: <span class="string">&quot;男&quot;</span> &#125; &#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1, obj2); <span class="comment">// &#123;name: &#x27;zs&#x27;, age: 18, info: &#123;…&#125;&#125; &#123;name: &#x27;zs&#x27;, age: 18, info: &#123;…&#125;&#125;</span></span><br><span class="line">obj1.<span class="property">name</span> = <span class="string">&quot;ls&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1, obj2); <span class="comment">// &#123;name: &#x27;ls&#x27;, age: 18, info: &#123;…&#125;&#125; &#123;name: &#x27;zs&#x27;, age: 18, info: &#123;…&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>使用<strong>浅拷贝解决赋值问题</strong>的方式：</p><ul><li>首先创建新对象然后使用for…in…进行赋值</li><li>使用Object.assign()方法进行赋值</li><li>使用扩展运算符<br><strong>浅拷贝的弊端</strong>：当对象里面没有嵌套引用类型的时候浅拷贝可以解决赋值问题，但是当对象嵌套了引用类型时，修改内层的引用类型时就又会产生赋值问题。</li></ul><h3 id="3-深拷贝"><a href="#3-深拷贝" class="headerlink" title="(3) 深拷贝"></a>(3) 深拷贝</h3><p>深拷贝：不管多少层数据结构，都百分百复制一份，变成两个一模一样但是毫不相干的数据结构</p><h4 id="方式一：递归"><a href="#方式一：递归" class="headerlink" title="方式一：递归"></a>方式一：递归</h4><p>利用函数封装，然后对被复制的的对象进行遍历，分别判断：</p><ul><li>如果是数组，给目标对象赋空数组，然后重新调用封装函数</li><li>如果是对象，给目标对象赋空对象，然后重新调用封装函数</li><li>如果是基本数据类型，直接赋值给目标对象</li><li>最后返回目标对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">info</span>: &#123; <span class="attr">sex</span>: <span class="string">&quot;男&quot;</span> &#125; &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">origin, target</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> origin) &#123;</span><br><span class="line">        <span class="keyword">if</span> (origin[k] <span class="keyword">instanceof</span> <span class="title class_">Object</span>) &#123;</span><br><span class="line">            target[k] = &#123;&#125;;</span><br><span class="line">            <span class="title function_">deepClone</span>(origin[k], target[k])</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (origin[k] <span class="keyword">instanceof</span> <span class="title class_">Array</span>) &#123;</span><br><span class="line">            target[k] = [];</span><br><span class="line">            <span class="title function_">deepClone</span>(origin[k], target[k])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target[k] = origin[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="title function_">deepClone</span>(obj1, &#123;&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1, obj2); <span class="comment">// &#123;name: &#x27;zs&#x27;, age: 18, info: &#123;…&#125;&#125;</span></span><br><span class="line">obj1.<span class="property">info</span>.<span class="property">sex</span> = <span class="string">&quot;女&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1, obj2); <span class="comment">// obj1中的sex改为女</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="方式二：利用JSON的方法"><a href="#方式二：利用JSON的方法" class="headerlink" title="方式二：利用JSON的方法"></a>方式二：利用JSON的方法</h4><p>先通过JSON.stringify()方法将被赋值的对象转为字符串，在通过JSON.parse()方法将字符串转为对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">info</span>: &#123; <span class="attr">sex</span>: <span class="string">&quot;男&quot;</span> &#125; &#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj1));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">// &#123;name: &#x27;zs&#x27;, age: 18, info: &#123;…&#125;&#125;</span></span><br><span class="line">obj1.<span class="property">info</span>.<span class="property">sex</span> = <span class="string">&quot;女&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1, obj2); <span class="comment">// obj1中的sex改为女</span></span><br></pre></td></tr></table></figure><p><strong>使用方式会产生的问题</strong></p><ul><li>如果obj里面存在时间对象,JSON.parse(JSON.stringify(obj))之后，时间对象变成了字符串。</li><li>如果obj里有RegExp、Error对象，则序列化的结果将只得到空对象。</li><li>如果obj里有函数，undefined，则序列化的结果会把函数， undefined丢失。</li><li>如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null。</li><li>JSON.stringify()只能序列化对象的可枚举的自有属性。如果obj中的对象是有构造函数生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor。</li><li>如果对象中存在循环引用的情况也无法正确实现深拷贝。<br><strong>解决方法</strong>：<br>可以使用 lodash 库来解决<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lodash </span></span><br><span class="line"><span class="comment">//  这个库  解决了 javascript中的 疑难杂症  比如深拷贝  npm  insall loadsh </span></span><br><span class="line"><span class="comment">// const &#123; cloneDeep &#125; = require(&#x27;lodash&#x27;)</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="二-不会销毁的函数执行空间"><a href="#二-不会销毁的函数执行空间" class="headerlink" title="二. 不会销毁的函数执行空间"></a>二. 不会销毁的函数执行空间</h2><p>当函数返回一个复杂数据类型，并且函数外部有变量接收这个复杂数据类型时，函数执行完毕后函数的执行空间不会销毁<br><strong>原因</strong>：函数执行完毕后，返回的是一个对象的地址<br><strong>如果要销毁这个空间</strong>：只需将接收这个复杂数据类型的变量指向别的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> res = <span class="title function_">fn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// &#123;name: &#x27;zs&#x27;, age: 22&#125;</span></span><br></pre></td></tr></table></figure><h2 id="三-闭包"><a href="#三-闭包" class="headerlink" title="三. 闭包"></a>三. 闭包</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="(1) 概念"></a>(1) 概念</h3><p><strong>官方定义</strong>：<strong>闭包</strong>（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，<strong>词法环境</strong>）的引用的组合。换而言之，<strong>闭包</strong>让开发者可以<strong>从内部函数访问外部函数的作用域</strong>。在 JavaScript 中，闭包会随着函数的创建而被同时创建。<br><strong>目的</strong>：在函数外部操作函数里面的私有变量（起到保护全局变量的作用）<br><strong>闭包</strong>：函数内的函数，<strong>有权访问另一个函数作用域内变量的函数都是闭包。</strong><br><strong>闭包条件</strong>：</p><ol><li>需要一个不会被销毁的函数执行空间</li><li>需要直接或间接返回一个函数</li><li>内部函数使用外部函数的私有变量<br><strong>特点</strong>：</li><li>可以在函数外面访问到函数内部的变量</li><li>延长了变量的生命周期</li><li>内存溢出<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 3.内部函数使用外部函数的私有变量</span></span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.需要直接或间接返回一个函数</span></span><br><span class="line">    <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.需要一个不会被销毁的函数执行空间</span></span><br><span class="line"><span class="comment">// 在outer外面使用了outer里面的变量</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="title function_">outer</span>()();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// 200</span></span><br></pre></td></tr></table></figure><strong>闭包的缺点</strong>：会造成内存溢出。<blockquote><p>由于闭包是内部函数引用了外部函数的变量，虽然延迟了变量的生命周期。但是如果闭包使用过多。会造成很多变量没有被垃圾回收处理以至于造成内存溢出。</p></blockquote></li></ol><p><strong>内存溢出解决方式</strong>：将引用的变量赋值为null</p><h3 id="2-闭包的问题处理方式（垃圾回收机制）"><a href="#2-闭包的问题处理方式（垃圾回收机制）" class="headerlink" title="(2) 闭包的问题处理方式（垃圾回收机制）"></a>(2) 闭包的问题处理方式（垃圾回收机制）</h3><ol><li>垃圾回收机制（Garbage Collction）简称GC，是JavaScript中使用的内存管理系统的基本组成部分，是为了防止内存泄漏</li><li>JavaScript是在创建变量（对象、字符串等）时自动进行了分配内存，并且在不使用他们时“自动释放。”</li><li>内存在不适用的时候就被垃圾回收器自动回收<br><strong>内存的生命周期</strong> JS环境中分配的内存，一般有如下生命周期：</li><li>内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存</li><li>内存使用：即读写内存，也就是使用变量、函数等</li><li>内存回收：使用完毕，由垃圾回收自动回收不再使用的内存<br><strong>垃圾回收的算法说明</strong> 所谓垃圾回收，核心思想就是如何判断内存是否已经不再会被使用了，如果是，就视为垃圾给释放掉<br>下面介绍两种常见的浏览器垃圾回收算法：引用计数法和标记清除法<br><strong>1.引用计数</strong><br>IE采用的引用计数算法，定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用<br>算法</li><li>跟踪记录每个值被引用的次数。</li><li>如果这个值被引用了一次，那么就会被记录一次。</li><li>多次引用会累加。</li><li>如果减少一个引用就减1。</li><li>如果引用次数是0，则释放内存。<br><strong>缺点</strong>：循环引用<br>如果两个对象互相引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄漏。<br><strong>2.标记清除法</strong><br>现代的浏览器已经不再使用引用计数法了 现代浏览通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的<br><strong>核心</strong>：</li><li>标记清除算法将“不再使用的对象”定义为“无法达到的对象”。</li><li>标记：就是从根部（在js中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。</li><li>回收：那些无法由根部出发触及到的对象被标记为不再使用。<br>参考地址：<a href="https://blog.csdn.net/zzy_999/article/details/128559934">https://blog.csdn.net/zzy_999&#x2F;article&#x2F;details&#x2F;128559934</a></li></ol><h3 id="3-闭包案例"><a href="#3-闭包案例" class="headerlink" title="(3) 闭包案例"></a>(3) 闭包案例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 输出什么</span></span><br><span class="line"><span class="comment">// for (var i = 1; i &lt;= 5; i++) &#123;</span></span><br><span class="line"><span class="comment">//     setTimeout(function () &#123;</span></span><br><span class="line"><span class="comment">//         console.log(i);</span></span><br><span class="line"><span class="comment">//     &#125;, 1000);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5个6</span></span><br><span class="line"><span class="comment">// 每一次循环的时候，都修改的是同一个变量i, 最后循环到了6</span></span><br><span class="line"><span class="comment">// 先执行同步代码，同步代码执行完毕之后，再执行异步代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="comment">// for (let i = 1; i &lt;= 5; i++) &#123;</span></span><br><span class="line"><span class="comment">//     setTimeout(function () &#123;</span></span><br><span class="line"><span class="comment">//         console.log(i);</span></span><br><span class="line"><span class="comment">//     &#125;, 0);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// let 有块级作用域， 循环的时候，每次循环的i都是不一样的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">i</span>) &#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fn</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 闭包 内部函数用了外部函数的变量 ，保存了i这个变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 自执行函数 可以自动执行依次</span></span><br><span class="line">    ! <span class="keyword">function</span> (<span class="params">i</span>) &#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 闭包 内部函数用了外部函数的变量，把外部函数的变量保存下来</span></span><br></pre></td></tr></table></figure><h2 id="四-沙箱模式"><a href="#四-沙箱模式" class="headerlink" title="四. 沙箱模式"></a>四. 沙箱模式</h2><p>沙箱模式：</p><ol><li>利用闭包</li><li>利用函数内间接返回一个对象</li><li>外部函数返回一个对象，对象内书写多个函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">200</span>;</span><br><span class="line">    <span class="comment">// 下面这个对象就是一个沙箱</span></span><br><span class="line">    <span class="keyword">const</span> obj = &#123;</span><br><span class="line">        <span class="title function_">getA</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">getB</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">setA</span>(<span class="params">num</span>) &#123;</span><br><span class="line">            a = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> res = <span class="title function_">outer</span>();</span><br><span class="line"><span class="comment">// console.log(res); // &#123;getA: ƒ, getB: ƒ, setA: ƒ&#125;</span></span><br><span class="line"><span class="comment">// console.log(res.getA()); // 100</span></span><br><span class="line">res.<span class="title function_">setA</span>(<span class="number">500</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="title function_">getA</span>()); <span class="comment">// 500</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res1 = <span class="title function_">outer</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res1.<span class="title function_">getA</span>()); <span class="comment">// 100 </span></span><br></pre></td></tr></table></figure></li></ol><h2 id="五-沙箱语法糖"><a href="#五-沙箱语法糖" class="headerlink" title="五. 沙箱语法糖"></a>五. 沙箱语法糖</h2><p>沙箱语法糖: 尽可能简化沙箱模式的语法<br>语法糖</p><blockquote><p>利用getter 和 setter来进行操作。 操作的时候， 对象.设置(获取) 名称</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;</span><br><span class="line">        <span class="comment">// get关键字  getter获取器，用来获取成员a</span></span><br><span class="line">        <span class="keyword">get</span> <span class="title function_">a</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">get</span> <span class="title function_">b</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> b</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span> <span class="title function_">a</span>(<span class="params">num</span>) &#123;</span><br><span class="line">            a = num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res = <span class="title function_">outer</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">a</span>); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">JS 深浅拷贝及闭包</summary>
    
    
    
    <category term="前端" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://fanxing28.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS 防抖、节流和函数柯理化</title>
    <link href="https://fanxing28.github.io/2023/12/14/%E5%89%8D%E7%AB%AF/JavaScript/JS%20%E9%98%B2%E6%8A%96%E3%80%81%E8%8A%82%E6%B5%81%E5%92%8C%E5%87%BD%E6%95%B0%E6%9F%AF%E7%90%86%E5%8C%96/"/>
    <id>https://fanxing28.github.io/2023/12/14/%E5%89%8D%E7%AB%AF/JavaScript/JS%20%E9%98%B2%E6%8A%96%E3%80%81%E8%8A%82%E6%B5%81%E5%92%8C%E5%87%BD%E6%95%B0%E6%9F%AF%E7%90%86%E5%8C%96/</id>
    <published>2023-12-14T14:27:00.000Z</published>
    <updated>2023-12-14T14:58:06.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-函数柯理化"><a href="#一-函数柯理化" class="headerlink" title="一. 函数柯理化"></a>一. 函数柯理化</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="(1) 概念"></a>(1) 概念</h3><p>作用：把一次传递两个参数，变成两次每次传递一个参数<br>目的：利用闭包，把第一次传递的参数保存下来（延长变量的生命周期）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">num2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        ƒ (num2) &#123;</span></span><br><span class="line"><span class="comment">                return num1 + num2;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>)(<span class="number">2</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="2-案例：正则验证密码"><a href="#2-案例：正则验证密码" class="headerlink" title="(2) 案例：正则验证密码"></a>(2) 案例：正则验证密码</h3><p><strong>方式一</strong>：判断正则写在函数内部，需要判断的值在函数外部测试</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testpw</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/^\w&#123;6,12&#125;$/</span>;</span><br><span class="line">    <span class="keyword">return</span> reg.<span class="title function_">test</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res1 = <span class="title function_">testpw</span>(<span class="string">&quot;12345jfiang&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> res2 = <span class="title function_">testpw</span>(<span class="string">&quot;jfiang&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res1, res2); <span class="comment">// true true</span></span><br></pre></td></tr></table></figure><p><strong>方式二</strong>：正则和测试的值都在函数外部同时传入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testpw</span>(<span class="params">reg, str</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> reg.<span class="title function_">test</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res1 = <span class="title function_">testpw</span>(<span class="regexp">/^\w&#123;6,12&#125;$/</span>, <span class="string">&quot;1234&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> res2 = <span class="title function_">testpw</span>(<span class="regexp">/^\w&#123;6,12&#125;$/</span>, <span class="string">&quot;1234fajin&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res1, res2); <span class="comment">// false true</span></span><br></pre></td></tr></table></figure><p><strong>方式三</strong>：利用柯理化（闭包）封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testpw</span>(<span class="params">reg</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">str</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> reg.<span class="title function_">test</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> test1 = <span class="title function_">testpw</span>(<span class="regexp">/^\w&#123;6,12&#125;$/</span>);</span><br><span class="line"><span class="keyword">const</span> res1 = <span class="title function_">test1</span>(<span class="string">&quot;1223&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res1); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 生成一个验证手机号的函数</span></span><br><span class="line"><span class="keyword">const</span> testPhone = <span class="title function_">testpw</span>(<span class="regexp">/^1\d&#123;10&#125;$/</span>);</span><br><span class="line"><span class="comment">// 校验手机号</span></span><br><span class="line"><span class="keyword">const</span> res2 = <span class="title function_">testPhone</span>(<span class="string">&#x27;2341200&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> res3 = <span class="title function_">testPhone</span>(<span class="string">&#x27;12312345678&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res2, res3); <span class="comment">// false true</span></span><br></pre></td></tr></table></figure><h3 id="3-函数柯理化的封装"><a href="#3-函数柯理化的封装" class="headerlink" title="(3) 函数柯理化的封装"></a>(3) 函数柯理化的封装</h3><p>函数柯理化封装</p><ol><li>是多个参数互相利用</li><li>需要两个功能<blockquote><p>功能函数</p></blockquote></li></ol><p>收集参数<br><strong>功能</strong>：实现拼接地址栏</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http</span>:<span class="comment">//localhost:8080/a/b</span></span><br><span class="line">    a : http </span><br><span class="line">    b : localhost</span><br><span class="line">    c : <span class="number">8080</span></span><br><span class="line">    d : <span class="regexp">/a/</span>b</span><br><span class="line">功能函数 把 a b c d 拼接起来</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并且要实现以下三种情况：</span></span><br><span class="line"><span class="comment">// 情况1</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="title function_">curry</span>(fn, <span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> res1 = <span class="title function_">res</span>(<span class="string">&#x27;localhost&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> res2 = <span class="title function_">res1</span>(<span class="string">&#x27;8080&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> res3 = <span class="title function_">res2</span>(<span class="string">&#x27;/a/b&#x27;</span>) <span class="comment">// http://localhost:8080/a/b</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res3);</span><br><span class="line"><span class="comment">// 情况2</span></span><br><span class="line"><span class="comment">// const res = curry(fn, &#x27;http&#x27;, &#x27;localhost&#x27;)</span></span><br><span class="line"><span class="comment">// const res1 = res(&#x27;8080&#x27;, &#x27;/a/b&#x27;) // // http://localhost:8080/a/b</span></span><br><span class="line"><span class="comment">// 情况3</span></span><br><span class="line"><span class="comment">// const res = curry(fn, &#x27;http&#x27;, &#x27;localhost&#x27;, &#x27;8080&#x27;, &#x27;/a/b&#x27;)() // // http://localhost:8080/a/b</span></span><br><span class="line"><span class="comment">// console.log(res);</span></span><br></pre></td></tr></table></figure><p><strong>实现</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a, b, c, d</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="string">&#x27;://&#x27;</span> + b + <span class="string">&#x27;:&#x27;</span> + c + d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 柯理化函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn, ...arg</span>) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    收集参数，判断参数的个数，够不够功能函数使用</span></span><br><span class="line"><span class="comment">        如果够了：执行功能函数</span></span><br><span class="line"><span class="comment">        如果不够：继续收集</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 对外部收集的参数进行处理</span></span><br><span class="line">    <span class="keyword">let</span> _arg = arg || []</span><br><span class="line">    <span class="comment">// 需要用_arg的length和 功能函数的参数个数进行比对</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取函数形参的个数</span></span><br><span class="line">    <span class="keyword">let</span> len = fn.<span class="property">length</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...arg</span>) &#123;</span><br><span class="line">        _arg = [..._arg, ...arg]</span><br><span class="line">        <span class="comment">// 用处理好的参数进行数量判断</span></span><br><span class="line">        <span class="keyword">if</span> (_arg.<span class="property">length</span> === len) &#123;</span><br><span class="line">            <span class="comment">// 处理好的参数  ==== 功能函数参数相同</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">fn</span>(..._arg)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 处理好的参数&lt;功能函数参数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">curry</span>(fn, ..._arg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// const res = curry(fn)</span></span><br></pre></td></tr></table></figure><h2 id="二-函数防抖"><a href="#二-函数防抖" class="headerlink" title="二. 函数防抖"></a>二. 函数防抖</h2><blockquote><p>通过setTimeout的方式，在一定的时间间隔内，将多次触发变成一次触发。（通俗的说是在最后一次点击间隔规定时间之后才能再次成功触发，否则触发不成功）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;ipt&quot;</span>&gt;</span><br><span class="line">&lt;!--  分割线 --&gt;</span><br><span class="line">ipt.<span class="property">oninput</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="property">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每键入一次就会将input框中的value值输出</span></span><br></pre></td></tr></table></figure><p><strong>防抖的实现思路</strong>：</p><ol><li>在防抖函数返回的函数的上级作用域设置一个定时器变量t置为null;</li><li>通过t来判断是否是第一次执行。</li><li>如果不是第一次执行，清空定时器</li><li>如果是第一次执行，则通过进行代码执行.</li><li>最后设置定时器，规定时间之后将t设置为null,使得间隔时间之后t为null，间隔时间之后的点击变为第一次点击。<br><strong>递进优化实现步骤</strong>：</li></ol><ul><li>第一步：简单实现<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;ipt&quot;</span>&gt;</span><br><span class="line">&lt;!-- 分割线 --&gt;</span><br><span class="line"><span class="keyword">let</span> t = <span class="literal">null</span>;</span><br><span class="line">ipt.<span class="property">oninput</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(t);</span><br><span class="line">    t = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一直键入值等待1.5s后输出最终值</span></span><br></pre></td></tr></table></figure></li><li>第二步：为了不污染全局，把变量放在函数里面<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;ipt&quot;</span>&gt;</span><br><span class="line">&lt;!-- 分割线 --&gt;</span><br><span class="line">ipt.<span class="property">oninput</span> = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> t = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(t);</span><br><span class="line">        t = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">        &#125;, <span class="number">1500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li><li>第三步：封装防抖函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;ipt&quot;</span>&gt;</span><br><span class="line">&lt;!-- 分割线 --&gt;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">prevent</span>(<span class="params">cb</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> t = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(t);</span><br><span class="line">        t = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            cb.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">        &#125;, <span class="number">1500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ipt.<span class="property">oninput</span> = <span class="title function_">prevent</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="三-函数节流"><a href="#三-函数节流" class="headerlink" title="三. 函数节流"></a>三. 函数节流</h2><blockquote><p>节流指的是减少一段时间内的触发频率。只有在上一次成功触发间隔规定时间之后，才能再次触发。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;ipt&quot;</span>&gt;</span><br><span class="line">&lt;!--  分割线 --&gt;</span><br><span class="line">ipt.<span class="property">oninput</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="property">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每键入一次就会将input框中的value值输出</span></span><br></pre></td></tr></table></figure><p><strong>节流的实现思路</strong>：</p><ol><li>在返回函数的上级作用域定义一个初始标记<code>flag = false</code>;</li><li>通过判断<code>flag 是否=== true</code>来确定是否已经触发</li><li>如果已经触发(flag &#x3D;&#x3D;&#x3D; true)，则中断函数</li><li>如果没有触发(flag &#x3D;&#x3D;&#x3D; false)，则让<code>flag = false</code>执行代码，执行后将<code>flag = true</code><br><strong>递进优化实现步骤</strong>：</li></ol><ul><li>第一步：简单实现<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;ipt&quot;</span>&gt;</span><br><span class="line">&lt;!-- 分割线 --&gt;</span><br><span class="line"><span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">ipt.<span class="property">oninput</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="keyword">return</span></span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;, <span class="number">2500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>第二步：使用闭包<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;ipt&quot;</span>&gt;</span><br><span class="line">&lt;!-- 分割线 --&gt;</span><br><span class="line">ipt.<span class="property">oninput</span> = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">return</span></span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;, <span class="number">2500</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li><li>第三步：封装<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;ipt&quot;</span>&gt;</span><br><span class="line">&lt;!-- 分割线 --&gt;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">out</span>(<span class="params">cb = () =&gt; &#123; &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">return</span></span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            cb.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;, <span class="number">2500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ipt.<span class="property">oninput</span> = <span class="title function_">out</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="四-节流与防抖的区别是什么？"><a href="#四-节流与防抖的区别是什么？" class="headerlink" title="四. 节流与防抖的区别是什么？"></a>四. 节流与防抖的区别是什么？</h2><ol><li>防抖只在最后一次成功点击之后间隔规定时间之后才能再次成功触发，如果在时间间隔之内就被点击，需要重新间隔时间间隔才能点击。</li><li>节流则不同，节流只要在上一次成功触发规定时间之后点击就能再次触发，中间的触发不会产生影响。</li></ol>]]></content>
    
    
    <summary type="html">JS 防抖、节流和函数柯理化</summary>
    
    
    
    <category term="前端" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://fanxing28.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS 正则表达式</title>
    <link href="https://fanxing28.github.io/2023/12/14/%E5%89%8D%E7%AB%AF/JavaScript/JS%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://fanxing28.github.io/2023/12/14/%E5%89%8D%E7%AB%AF/JavaScript/JS%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2023-12-14T14:11:00.000Z</published>
    <updated>2023-12-14T14:56:23.664Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式（英语：Regular Expression，在代码中常简写为regex、regexp或RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。</p><h2 id="一-什么是正则表达式？"><a href="#一-什么是正则表达式？" class="headerlink" title="一. 什么是正则表达式？"></a>一. 什么是正则表达式？</h2><p>正则表达式是由一个字符序列形成的搜索模式。 当你在文本中搜索数据时，你可以用搜索模式来描述你要查询的内容。 正则表达式可以是一个简单的字符，或一个更复杂的模式。 正则表达式可用于所有文本搜索和文本替换的操作。</p><h2 id="二-创建正则表达式"><a href="#二-创建正则表达式" class="headerlink" title="二. 创建正则表达式"></a>二. 创建正则表达式</h2><p><strong>(1) 内置构造函数方式创建</strong><br>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> 变量 = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;正则表达式&quot;</span>,<span class="string">&quot;修饰符&quot;</span>);</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>正则表达式：可以是<strong>字符串或者变量</strong></li><li>修饰符：可以是全局匹配（g）、忽略大小写（i）、多行匹配（m）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eg: 判断字符串（abCDcs）中是否有（abcd），并且全局匹配（g）、忽略大小写（i）</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;abcd&#x27;</span>, <span class="string">&#x27;ig&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&#x27;abCDcs&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><strong>(2) 字面量方式创建</strong><br>语法：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> 变量 = <span class="regexp">/正则表达式/</span>修饰符</span><br></pre></td></tr></table></figure><strong>注</strong>：使用字面量创建的正则表达式只能是<strong>字符串</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eg:</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/abcd/ig</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&#x27;abCDcs&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="三-正则表达式修饰符"><a href="#三-正则表达式修饰符" class="headerlink" title="三. 正则表达式修饰符"></a>三. 正则表达式修饰符</h2><p><strong>修饰符</strong> 可以在全局搜索中不区分大小写:</p><blockquote><p>i（ignore case）：忽略大小写 g（global）：执行全局匹配（查找所有匹配而非在找到第一个匹配后停止） m（multiple lines）：执行多行匹配</p></blockquote><p>设置匹配模式时，可以都不设置，也可以设置1个，也可以全设置，设置时没有顺序要求。</p><h2 id="四-正则表达式的方法"><a href="#四-正则表达式的方法" class="headerlink" title="四. 正则表达式的方法"></a>四. 正则表达式的方法</h2><h3 id="一-正则对象的方法"><a href="#一-正则对象的方法" class="headerlink" title="(一) 正则对象的方法"></a>(一) 正则对象的方法</h3><h4 id="1-test"><a href="#1-test" class="headerlink" title="(1) test()"></a>(1) test()</h4><p>概念：用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。 <strong>语法</strong>：正则表达式.test(字符串） <strong>返回值</strong>：返回一个布尔值，如果字符串中含有匹配的文本，则返回 true，否则返回 false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;e&quot;</span>);<span class="comment">// 检查下列句子中是否含有e</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(a.<span class="title function_">test</span>(<span class="string">&quot;There is a good thing&quot;</span>));</span><br><span class="line">&lt;!-- 结果：<span class="literal">true</span> --&gt;</span><br></pre></td></tr></table></figure><h4 id="2-exec"><a href="#2-exec" class="headerlink" title="(2) exec()"></a>(2) exec()</h4><p>概念：在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null。 <strong>语法</strong>：正则表达式.exec(字符串） <strong>返回值</strong>：把字符串中符合正则要求的<strong>第一项</strong>以及一些其他信息，以<strong>数组的形式</strong>返回<br><strong>注</strong>：该方法是将字符串中满足正则表达式的部分提取出来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\d[a-z]/</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;ab56efg&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> res = reg.<span class="title function_">exec</span>(str);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line"><span class="comment">// [&#x27;6e&#x27;, index: 3, input: &#x27;ab56efg&#x27;, groups: undefined]</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    返回值中的第一项：匹配的值（&#x27;6e&#x27;）</span></span><br><span class="line"><span class="comment">    第二项：匹配的索引，只找第一个（index: 3）</span></span><br><span class="line"><span class="comment">    第三项：匹配的字符串（input: &#x27;ab56efg&#x27;）</span></span><br><span class="line"><span class="comment">    第四项：分组（这里没有所以，groups: undefined）（可以忽略）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//遇到满足条件的就返回，所以只返回5</span></span><br></pre></td></tr></table></figure><h3 id="二-字符串支持的正则方法"><a href="#二-字符串支持的正则方法" class="headerlink" title="(二) 字符串支持的正则方法"></a>(二) 字符串支持的正则方法</h3><h4 id="1-split"><a href="#1-split" class="headerlink" title="(1) split()"></a>(1) split()</h4><p>概念：将一个字符串拆分为一个数组 <strong>语法</strong>：字符串.split(正则表达式&#x2F;字符串) <strong>返回值</strong>：返回被拆分后的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;1j1j1k2d7o&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">split</span>(<span class="string">&quot;k&quot;</span>)); <span class="comment">// [&#x27;1j1j1&#x27;, &#x27;2d7o&#x27;]</span></span><br><span class="line"><span class="keyword">let</span> result = str.<span class="title function_">split</span>(<span class="regexp">/[A-z]/</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// [&#x27;1&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;7&#x27;, &#x27;&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="2-replace"><a href="#2-replace" class="headerlink" title="(2) replace()"></a>(2) replace()</h4><p>概念：用于在字符串中用一些字符串替换另一些字符串，或替换一个与正则表达式匹配的子串。 <strong>语法</strong>：字符串.replace(换下字符串，换上字符串)<br><strong>注</strong>：第二参数可以是字符串也可以是回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eg: 使用正则表达式且不区分大小写将字符串中的 Cat 替换为 Root</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;Visit Cat !&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> txt = str.<span class="title function_">replace</span>(<span class="regexp">/cat/i</span>,<span class="string">&quot;Root&quot;</span>);</span><br></pre></td></tr></table></figure><p>结果输出为：<code>Visit Root !</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eg: 批量替换敏感词</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;HH&#x27;</span>, <span class="string">&#x27;MM&#x27;</span>, <span class="string">&#x27;NN&#x27;</span>]</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;aHHdfasMMdfaNNdsfaNNsNNdffas&#x27;</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(arr.<span class="title function_">join</span>(<span class="string">&quot;|&quot;</span>), <span class="string">&quot;g&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">replace</span>(reg, <span class="string">&#x27;**&#x27;</span>)); <span class="comment">// a**dfas**dfa**dsfa**s**dffas</span></span><br></pre></td></tr></table></figure><h4 id="3-match"><a href="#3-match" class="headerlink" title="(3) match()"></a>(3) match()</h4><p>概念：检索返回一个字符串匹配正则表达式的结果。 <strong>语法</strong>：字符串.match(正则表达式) <strong>返回值</strong>：以<strong>数组</strong>的格式返回满足条件的第一项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg=<span class="regexp">/[a-z]/g</span>;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;ab56efg&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> res=str.<span class="title function_">match</span>(reg); <span class="comment">//字符串中满足表达式的部分提取出来</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);<span class="comment">//结果：[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;]</span></span><br></pre></td></tr></table></figure><p><strong>match() 和exec()的同异点</strong><br><strong>区别</strong>：</p><ul><li>exec()方法是：正则表达式提供的方法</li><li>match()方法是：字符串的方法<br><strong>相同</strong>： 都返回一个数组，只要匹配到符合规则的数据就返回</li></ul><h4 id="4-search"><a href="#4-search" class="headerlink" title="(4) search()"></a>(4) search()</h4><p><strong>search()</strong> 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并$\color{red} {返回子串的起始位置} $。 <strong>语法</strong>：字符串.search(正则表达式） <strong>返回值</strong>：找到目标值返回对应的<strong>索引</strong>，没找到返回<code>-1</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eg:使用正则表达式搜索 &quot;Root&quot; 字符串，且不区分大小写</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;Visit Root!&quot;</span>; </span><br><span class="line"><span class="keyword">var</span> n = str.<span class="title function_">search</span>(<span class="regexp">/Root/i</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h2 id="五-正则表达式模式"><a href="#五-正则表达式模式" class="headerlink" title="五. 正则表达式模式"></a>五. 正则表达式模式</h2><h3 id="1-方括号"><a href="#1-方括号" class="headerlink" title="(1) 方括号"></a>(1) 方括号</h3><p>方括号用于查找某个范围内的字符：</p><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>[abc]</td><td>查找方括号之间的任何字符。</td></tr><tr><td>[0-9]</td><td>查找任何从 0 至 9 的数字。</td></tr><tr><td>(x</td><td>y)</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eg: 匹配数字字母中的任意一个字符</span></span><br><span class="line">[a-zA-<span class="variable constant_">Z0</span>-<span class="number">9</span>]</span><br></pre></td></tr></table></figure><h3 id="2-元字符"><a href="#2-元字符" class="headerlink" title="(2) 元字符"></a>(2) 元字符</h3><p>元字符（Metacharacter）是拥有特殊含义的字符：</p><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>（小数点）默认匹配除换行符之外的任何单个字符。</td></tr><tr><td>\w</td><td>匹配一个单字字符（字母、数字或者下划线）。等价于 <code>[A-Za-z0-9_]</code>。</td></tr><tr><td>\W</td><td>匹配一个非单字字符。等价于 <code>[^A-Za-z0-9_]</code>。</td></tr><tr><td>\d</td><td>查找数字（至少含有一个数字(0~9)）</td></tr><tr><td>\D</td><td>查找非数字字符（至少含有一个非数字）</td></tr><tr><td>\s</td><td>查找空白字符（至少含有一个空白字符(空格、缩进、\b…)）</td></tr><tr><td>\S</td><td>查找非空白字符（至少含有一个不是空白字符）</td></tr><tr><td>\b</td><td>匹配单词边界</td></tr><tr><td>\B</td><td>匹配非单词边界</td></tr><tr><td>\0</td><td>查找NUL字符</td></tr><tr><td>\n</td><td>查找换行符</td></tr><tr><td>\f</td><td>查找换页符</td></tr><tr><td>\r</td><td>查找回车符</td></tr><tr><td>\t</td><td>查找制表符</td></tr><tr><td>\v</td><td>查找垂直制表符</td></tr><tr><td>\xxx</td><td>查找以八进制 xxx 规定的字符</td></tr><tr><td>\xdd</td><td>查找以十六进制 dd 规定的字符</td></tr><tr><td>\uxxxx</td><td>查找以十六进制 xxxx 规定的 Unicode 字符</td></tr><tr><td>实例</td><td></td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\W/</span>  <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&quot;!@#!&quot;</span>))</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\D/</span>  <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&quot;123&quot;</span>))</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\bchild\b/</span>  <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&quot;hello children&quot;</span>))</span><br></pre></td></tr></table></figure><h3 id="3-量词"><a href="#3-量词" class="headerlink" title="(3) 量词"></a>(3) 量词</h3><p>|量词|描述| |-|-| |?|出现0次或一次| |+|出现一次或多次| |*|出现0次或多次| |{n}|出现n次| |{n,m}|出现n到m次| |{n,}|至少出现n次|</p><p>实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a&#123;3&#125;/</span>;<span class="comment">//判断a是否连续出现3次</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&quot;aaabc&quot;</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&quot;abc&quot;</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(ab)&#123;3&#125;/</span>;<span class="comment">//判断ab是否连续出现3次</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&quot;abababc&quot;</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&quot;abc&quot;</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/ab&#123;1,3&#125;c/</span>;<span class="comment">//判断b是否连续出现1-3次</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&quot;abbbc&quot;</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&quot;abbbbbc&quot;</span>));<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&quot;bac&quot;</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="4-正则语法"><a href="#4-正则语法" class="headerlink" title="(4) 正则语法"></a>(4) 正则语法</h3><table><thead><tr><th>正则</th><th>描述</th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td>[ ]</td><td>或</td></tr><tr><td>[^ ]</td><td>除了</td></tr><tr><td>[a-z]</td><td>小写字母</td></tr><tr><td>[A-Z]</td><td>大写字母</td></tr><tr><td>[A-z]</td><td>任意字母</td></tr><tr><td>^</td><td>开头</td></tr><tr><td>$</td><td>结尾</td></tr><tr><td>实例：</td><td></td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查字符串中是否含有a或b</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a|b/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&quot;bcd&quot;</span>))<span class="comment">//结果：true</span></span><br><span class="line"><span class="comment">//检查字符串中是否含有字母</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[a-z]/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&quot;bcdfsji&quot;</span>))<span class="comment">//结果：true</span></span><br><span class="line"><span class="comment">//检查字符串中是否含有abd或abc或abf</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/ab[cdf]/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&quot;bcabcji&quot;</span>))<span class="comment">//结果：true</span></span><br><span class="line"><span class="comment">//检查一个字符串是否以a结尾</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a$/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&quot;bcabcjia&quot;</span>))<span class="comment">//结果：true</span></span><br><span class="line"><span class="comment">//如果在正则表达式中同时使用^ $则要求必须完全符合正则表达式</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^a$/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&quot;as&quot;</span>))<span class="comment">//结果：false</span></span><br></pre></td></tr></table></figure><h3 id="5-重复元字符"><a href="#5-重复元字符" class="headerlink" title="(5) 重复元字符"></a>(5) 重复元字符</h3><p><strong>符号</strong>: <code>\数字</code><br><strong>作用</strong>: 表示重复第n个小括号的内容，要求和第n个小括号的内容一模一样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示这个()里面的整体内容出现2次就可以。不要求一模一样</span></span><br><span class="line"><span class="comment">// var reg1 = /^(abc|def)&#123;2&#125;$/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示 \1 位置 需要出现一个 和 第一个 小括号 一模一样的内容</span></span><br><span class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/^(abc|def)\1$/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&#x27;abcabc&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&#x27;defdef&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&#x27;abcdef&#x27;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/^(abc|def)(哈哈|嘻嘻)\2$/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&#x27;abc哈哈哈哈&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&#x27;abc哈哈嘻嘻&#x27;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&#x27;abc嘻嘻嘻嘻&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="6-正则的捕获方式"><a href="#6-正则的捕获方式" class="headerlink" title="(6) 正则的捕获方式"></a>(6) 正则的捕获方式</h3><p><strong>语法</strong>：正则表达式.exec(字符串) <strong>作用</strong>：始字符串中捕获到符合正则规则的字符串片段<br><strong>返回值</strong>：</p><ol><li>当原始字符串没有符合规则的时候，返回null</li><li>当原始字符串由符合规则的片段的时候：<blockquote><p>返回值必然是一个数组，数组的[0] 是捕获出来的字符串片段</p></blockquote></li></ol><ul><li>没有(), 没有g<blockquote><p>不管写多少次，只能捕获第一组匹配规则的字符串片段</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d&#123;3&#125;/</span> </span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;adfa123sals456hdfl789kasakhdf012&#x27;</span> </span><br><span class="line"><span class="keyword">var</span> res = reg.<span class="title function_">exec</span>(str) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">//[&#x27;123&#x27;,index:4,input:&#x27;adfa123sals456hdfl789kasakhdf012&#x27;, groups: undefined] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">exec</span>(str)); </span><br><span class="line"><span class="comment">// [&#x27;123&#x27;, index: 4, input: &#x27;adfa123sals456hdfl789kasakhdf012&#x27;, groups: undefined] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">exec</span>(str)); </span><br><span class="line"><span class="comment">// [&#x27;123&#x27;, index: 4, input: &#x27;adfa123sals456hdfl789kasakhdf012&#x27;, groups: undefined]</span></span><br></pre></td></tr></table></figure><ul><li>有()<blockquote><p>会在返回值数组的[1]开始，依次是每一个()中单独的内容</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\d&#123;2&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d)(\d|x)/</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;22230120050101123x&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">exec</span>(str));</span><br><span class="line"><span class="comment">// [&#x27;22230120050101123x&#x27;, &#x27;22&#x27;, &#x27;23&#x27;, &#x27;01&#x27;, &#x27;2005&#x27;, &#x27;01&#x27;, &#x27;01&#x27;, &#x27;12&#x27;, &#x27;3&#x27;, &#x27;x&#x27;, index: 0, input: &#x27;22230120050101123x&#x27;, groups: undefined]</span></span><br></pre></td></tr></table></figure></li></ul></li><li>有g<blockquote><p>g 叫做全局标识符</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d&#123;3&#125;/g</span> <span class="keyword">var</span> str = <span class="string">&#x27;adfa123sals456hdfl789kasakhdf012&#x27;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">exec</span>(str)); </span><br><span class="line"><span class="comment">// [&#x27;123&#x27;, index: 4, input: &#x27;adfa123sals456hdfl789kasakhdf012&#x27;, groups: undefined] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">exec</span>(str)); </span><br><span class="line"><span class="comment">// [&#x27;456&#x27;, index: 11, input: &#x27;adfa123sals456hdfl789kasakhdf012&#x27;, groups: undefined] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">exec</span>(str)); </span><br><span class="line"><span class="comment">// [&#x27;789&#x27;, index: 18, input: &#x27;adfa123sals456hdfl789kasakhdf012&#x27;, groups: undefined]</span></span><br></pre></td></tr></table></figure>第二次捕获开始会从第一次捕获的结束为止开始检索<br>直到找不到内容，返回null<br><strong>匹配但是不捕获</strong><blockquote><p>当我们需要使用()这个整体作用，但是不需要把()里面的内容单独捕获的时候：<strong>可以书写( ?: )</strong></p></blockquote></li></ul><h2 id="六-正则的两大特性"><a href="#六-正则的两大特性" class="headerlink" title="六. 正则的两大特性"></a>六. 正则的两大特性</h2><ol><li>懒惰<blockquote><p>每次捕获的时候都会从字符串[0]开始检索 解决：给正则添加标识符g，（查找所有匹配而非在找到第一个匹配后停止）</p></blockquote></li><li>贪婪<blockquote><p>每次在捕获内容的时候，尽可能多的去捕获内容 解决：使用非贪婪限定符(在原来的限定符后面加一个?)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪婪捕获</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;1234567abcd&#x27;</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\d*/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">exec</span>(str)); <span class="comment">// [&#x27;1234567&#x27;, index: 0, input: &#x27;1234567abcd&#x27;, groups: undefined]</span></span><br></pre></td></tr></table></figure>贪婪限定符：<code>（*、+、?、&#123;n,&#125;、&#123;n,m&#125;）</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪婪限定符</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/&lt;div.*&gt;/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">exec</span>(str)); </span><br><span class="line"><span class="comment">// &#x27;&lt;div class=&quot;box&quot; id=&quot;box&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&#x27;</span></span><br></pre></td></tr></table></figure>非贪婪限定符：<code>（* ?、+?、??、&#123;n,&#125;?、&#123;n,m&#125;?）</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非贪婪限定符</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/&lt;div.*?&gt;/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">exec</span>(str)); </span><br><span class="line"><span class="comment">// &#x27;&lt;div class=&quot;box&quot; id=&quot;box&quot;&gt;&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="七-ES9新特性（正则扩展）"><a href="#七-ES9新特性（正则扩展）" class="headerlink" title="七. ES9新特性（正则扩展）"></a>七. ES9新特性（正则扩展）</h2><h3 id="1-命名捕获分组"><a href="#1-命名捕获分组" class="headerlink" title="(1) 命名捕获分组"></a>(1) 命名捕获分组</h3><p>捕获：对正则匹配的数据进行<code>(.*)</code>单独提取。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个字符串 </span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;&lt;a href=&quot;http://www.baidu.com&quot;&gt;你好&lt;/a&gt;&#x27;</span>; </span><br><span class="line"><span class="comment">// 需求：提取url和标签内文本 </span></span><br><span class="line"><span class="comment">// 之前的写法 </span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/&lt;a href=&quot;(.*)&quot;&gt;(.*)&lt;\/a&gt;/</span>; </span><br><span class="line"><span class="keyword">const</span> result = reg.<span class="title function_">exec</span>(str); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); </span><br><span class="line"><span class="comment">// 结果是一个数组，第一个元素是所匹配的所有字符串 </span></span><br><span class="line"><span class="comment">// 第二个元素是第一个(.*)匹配到的字符串 </span></span><br><span class="line"><span class="comment">// 第三个元素是第二个(.*)匹配到的字符串 </span></span><br><span class="line"><span class="comment">// 我们将此称之为捕获 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result[<span class="number">1</span>]); <span class="comment">// http://www.baidu.com</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result[<span class="number">2</span>]); <span class="comment">// 你好</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用命名捕获分组的写法：</span></span><br><span class="line"><span class="keyword">const</span> reg1 = <span class="regexp">/&lt;a href=&quot;(?&lt;url&gt;.*)&quot;&gt;(?&lt;text&gt;.*)&lt;\/a&gt;/</span>; </span><br><span class="line"><span class="keyword">const</span> result1 = reg1.<span class="title function_">exec</span>(str); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result1); </span><br><span class="line"><span class="comment">// 这里的结果多了一个groups </span></span><br><span class="line"><span class="comment">// groups: </span></span><br><span class="line"><span class="comment">// text:&quot;你好&quot; </span></span><br><span class="line"><span class="comment">// url:&quot;http://www.baidu.com&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result1.<span class="property">groups</span>.<span class="property">url</span>); <span class="comment">// http://www.baidu.com</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result1.<span class="property">groups</span>.<span class="property">text</span>); <span class="comment">// 你好</span></span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="https://fanxingnotes.oss-cn-beijing.aliyuncs.com/images/others/%25E5%2591%25BD%25E5%2590%258D%25E6%258D%2595%25E8%258E%25B7%25E5%2588%2586%25E7%25BB%2584.jpg" class="lazyload placeholder" data-srcset="https://fanxingnotes.oss-cn-beijing.aliyuncs.com/images/others/%25E5%2591%25BD%25E5%2590%258D%25E6%258D%2595%25E8%258E%25B7%25E5%2588%2586%25E7%25BB%2584.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://imagesfx.oss-cn-shanghai.aliyuncs.com/img/JavaScript/%E5%91%BD%E5%90%8D%E6%8D%95%E8%8E%B7%E5%88%86%E7%BB%84.jpg?x-oss-process=style/imagesfx"></p><h3 id="2-反向断言"><a href="#2-反向断言" class="headerlink" title="(2) 反向断言"></a>(2) 反向断言</h3><p>断言：判断这次的匹配结果是否正确<br>正向断言&#x2F;反向断言 做一个唯一性的识别<br>正向断言（目标的后面）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;JS314你知道么5呀&quot;</span>; </span><br><span class="line"><span class="comment">// 需求：我们只想匹配到5 </span></span><br><span class="line"><span class="comment">// 正向断言 </span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/\d+(?=呀)/</span>;  </span><br><span class="line"><span class="keyword">const</span> result = reg.<span class="title function_">exec</span>(str); </span><br><span class="line"><span class="comment">// [&#x27;5&#x27;, index: 9, input: &#x27;JS314你知道么5呀&#x27;, groups: undefined]</span></span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://fanxingnotes.oss-cn-beijing.aliyuncs.com/images/others/%25E5%258F%258D%25E5%2590%2591%25E6%2596%25AD%25E8%25A8%2580.jpg" class="lazyload placeholder" data-srcset="https://fanxingnotes.oss-cn-beijing.aliyuncs.com/images/others/%25E5%258F%258D%25E5%2590%2591%25E6%2596%25AD%25E8%25A8%2580.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://imagesfx.oss-cn-shanghai.aliyuncs.com/img/JavaScript/%E5%8F%8D%E5%90%91%E6%96%AD%E8%A8%80.jpg?x-oss-process=style/imagesfx"><br>反向断言（目标的前面）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;JS314你知道么5呀&quot;</span>; </span><br><span class="line"><span class="comment">// 反向断言 </span></span><br><span class="line"><span class="keyword">const</span> reg1 = <span class="regexp">/(?&lt;=么)\d+/</span>; </span><br><span class="line"><span class="keyword">const</span> result1 = reg1.<span class="title function_">exec</span>(str); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result1); </span><br><span class="line"><span class="comment">// [&#x27;5&#x27;, index: 9, input: &#x27;JS314你知道么5呀&#x27;, groups: undefined]</span></span><br></pre></td></tr></table></figure><p>结果：<br><img src="https://fanxingnotes.oss-cn-beijing.aliyuncs.com/images/others/%25E5%258F%258D%25E5%2590%2591%25E6%2596%25AD%25E8%25A8%2580.jpg" class="lazyload placeholder" data-srcset="https://fanxingnotes.oss-cn-beijing.aliyuncs.com/images/others/%25E5%258F%258D%25E5%2590%2591%25E6%2596%25AD%25E8%25A8%2580.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://imagesfx.oss-cn-shanghai.aliyuncs.com/img/JavaScript/%E5%8F%8D%E5%90%91%E6%96%AD%E8%A8%80.jpg?x-oss-process=style/imagesfx"></p><h3 id="3-dotAll-模式"><a href="#3-dotAll-模式" class="headerlink" title="(3) dotAll 模式"></a>(3) dotAll 模式</h3><p>dot就是. 元字符，表示除换行符之外的任意单个字符<br><strong>之前的写法：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let str = `</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>b<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>c<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>d<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">`;</span><br><span class="line">const reg = /<span class="tag">&lt;<span class="name">li</span>&gt;</span>\s+<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>(.*?)&lt;\/a&gt;\s+<span class="tag">&lt;<span class="name">p</span>&gt;</span>(.*?)&lt;\/p&gt;/;</span><br><span class="line">console.log(reg.exec(str));</span><br></pre></td></tr></table></figure><p><strong>结果：</strong><br><img src="https://fanxingnotes.oss-cn-beijing.aliyuncs.com/images/others/dotAll%25E6%25A8%25A1%25E5%25BC%258F%25E5%2589%258D.jpg" class="lazyload placeholder" data-srcset="https://fanxingnotes.oss-cn-beijing.aliyuncs.com/images/others/dotAll%25E6%25A8%25A1%25E5%25BC%258F%25E5%2589%258D.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://imagesfx.oss-cn-shanghai.aliyuncs.com/img/JavaScript/dotAll%E6%A8%A1%E5%BC%8F%E5%89%8D.jpg?x-oss-process=style/imagesfx"><br><strong>使用dotAll后：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let str = `</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>b<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>c<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>d<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">`;</span><br><span class="line">// const reg = /<span class="tag">&lt;<span class="name">li</span>&gt;</span>\s+<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>(.*?)&lt;\/a&gt;\s+<span class="tag">&lt;<span class="name">p</span>&gt;</span>(.*?)&lt;\/p&gt;/g;</span><br><span class="line">const reg = /<span class="tag">&lt;<span class="name">li</span>&gt;</span>.*?<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>(.*?)&lt;\/a&gt;.*?<span class="tag">&lt;<span class="name">p</span>&gt;</span>(.*?)&lt;\/p&gt;/gs;</span><br><span class="line">// console.log(reg.exec(str));</span><br><span class="line">let result;</span><br><span class="line">while ((result = reg.exec(str))) console.log(result);</span><br></pre></td></tr></table></figure><p>g为全局匹配 匹配不到是返回null，结束循环<br><strong>结果：</strong><br><img src="https://fanxingnotes.oss-cn-beijing.aliyuncs.com/images/others/dotAll%25E6%25A8%25A1%25E5%25BC%258F%25E5%2590%258E.jpg" class="lazyload placeholder" data-srcset="https://fanxingnotes.oss-cn-beijing.aliyuncs.com/images/others/dotAll%25E6%25A8%25A1%25E5%25BC%258F%25E5%2590%258E.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://imagesfx.oss-cn-shanghai.aliyuncs.com/img/JavaScript/dotAll%E6%A8%A1%E5%BC%8F%E5%90%8E.jpg?x-oss-process=style/imagesfx"></p><h2 id="八-案例"><a href="#八-案例" class="headerlink" title="八. 案例"></a>八. 案例</h2><p><strong>规则</strong>：</p><ul><li>6 ~ 12 位</li><li>只能包含数字字母下划线 \w</li><li>不能以 下划线开头<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^[0-9a-zA-Z]\w&#123;5,11&#125;$/</span></span><br></pre></td></tr></table></figure><strong>案例二</strong>：书写正则验证邮箱<br><strong>规则</strong>：</li><li>@ 前面, 和用户名规则一致</li><li>邮箱类型只接受 163 qq sina</li><li>后缀只接受 com cn<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^[0-9a-zA-Z]\w&#123;5,11&#125;@(163|qq|sina)\.(com|cn)$/</span></span><br></pre></td></tr></table></figure><strong>案例三</strong>：书写正则验证手机号<br><strong>规则</strong>：</li><li>前面有可能带有 +86 有可能没有 ? {0,1}</li><li>+86 和 电话号之间有可能有空格有可能没有</li><li>号段只接受 133 135 188<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^(\+86 ?)?(133|135|188)\d&#123;8&#125;$/</span></span><br></pre></td></tr></table></figure><strong>案例四</strong>：书写正则验证 0 ~ 255 的数字<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^(\d&#123;1,2&#125;|1\d&#123;2&#125;|2[0-4]\d|25[0-5])$/</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 验证：<span class="number">0</span> ~ <span class="number">666</span> --&gt;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^(\d&#123;1,2&#125;|[1-5]\d&#123;2&#125;|6[0-5]\d|66[0-6])$/</span></span><br></pre></td></tr></table></figure><strong>案例五</strong>：连字符和驼峰之间的转换<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连字符转驼峰</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;get-element-by-id&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> res = str.<span class="title function_">replace</span>(<span class="regexp">/-[a-z]/g</span>, <span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result.<span class="title function_">slice</span>(<span class="number">1</span>).<span class="title function_">toUpperCase</span>();</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// getElementById</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 驼峰转连字符</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;getElementById&#x27;</span></span><br><span class="line"><span class="keyword">let</span> res = str.<span class="title function_">replace</span>(<span class="regexp">/[A-Z]/g</span>, <span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;-&#x27;</span> + result.<span class="title function_">slice</span>(<span class="number">0</span>).<span class="title function_">toLowerCase</span>();</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// get-element-by-id</span></span><br></pre></td></tr></table></figure><strong>案例六</strong>：封装函数实现字符串首尾空格<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reTrim</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="comment">// 首先判断是不是一个字符串</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">typeof</span> str === <span class="string">&#x27;string&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">replace</span>(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">reTrim</span>(str));</span><br></pre></td></tr></table></figure><strong>案例七</strong>：敏感词替换<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eg: 批量替换敏感词</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;HH&#x27;</span>, <span class="string">&#x27;MM&#x27;</span>, <span class="string">&#x27;NN&#x27;</span>]</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;aHHdfasMMdfaNNdsfaNNsNNdffas&#x27;</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(arr.<span class="title function_">join</span>(<span class="string">&quot;|&quot;</span>), <span class="string">&quot;g&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">replace</span>(reg, <span class="string">&#x27;**&#x27;</span>)); <span class="comment">// a**dfas**dfa**dsfa**s**dffas</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">正则表达式（英语：Regular Expression，在代码中常简写为regex、regexp或RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。</summary>
    
    
    
    <category term="前端" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://fanxing28.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://fanxing28.github.io/2023/12/14/%E5%90%8E%E7%AB%AF/PHP/PHP%20%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://fanxing28.github.io/2023/12/14/%E5%90%8E%E7%AB%AF/PHP/PHP%20%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2023-12-14T14:09:17.141Z</published>
    <updated>2023-12-14T14:56:23.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h1><p>PHP</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PHP&quot;&gt;&lt;a href=&quot;#PHP&quot; class=&quot;headerlink&quot; title=&quot;PHP&quot;&gt;&lt;/a&gt;PHP&lt;/h1&gt;&lt;p&gt;PHP&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="https://fanxing28.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="PHP" scheme="https://fanxing28.github.io/categories/%E5%90%8E%E7%AB%AF/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>Promise 概念和方法</title>
    <link href="https://fanxing28.github.io/2023/12/14/%E5%89%8D%E7%AB%AF/RequestData/Promise%20%E6%A6%82%E5%BF%B5%E5%92%8C%E6%96%B9%E6%B3%95/"/>
    <id>https://fanxing28.github.io/2023/12/14/%E5%89%8D%E7%AB%AF/RequestData/Promise%20%E6%A6%82%E5%BF%B5%E5%92%8C%E6%96%B9%E6%B3%95/</id>
    <published>2023-12-14T13:58:00.000Z</published>
    <updated>2023-12-14T14:56:23.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概念"><a href="#一-概念" class="headerlink" title="一. 概念"></a>一. 概念</h2><p>Promise是<strong>ES6 新增</strong>的特性<br><strong>目的</strong>：用来解决异步解决回调地狱问题<br>利用Promise类创建promise实例对象，类的参数是回调函数，回调函数又有两个参数(一般约定为resolve(成功)和reject(失败))<br><strong>Promise 的基本语法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 实例对象 = <span class="keyword">new</span> <span class="title class_">Promise</span>(回调函数)</span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve,reject</span>)&#123;&#125;);</span><br></pre></td></tr></table></figure><p>回调函数中的参数：</p><ul><li>resolve：表示**(成功的回调)**，直接去找then，并且执行then里面的代码，同时将resolve里面的参数传递给then里面的函数。</li><li>reject：表示**(失败的回调)**，直接去找catch，并且执行catch里面的代码，同时将reject里面的参数传递给catch里面的函数。<br>Promise 的三个状态：</li><li>持续：pending</li><li>成功：fulfilled</li><li>失败：rejected<br>Promise 的两种转换(三种状态变成两种可能)：</li><li>从持续状态转换到成功</li><li>从持续状态转换到失败<br>Promise 的实例原型方法：</li><li>then(函数)：成功状态的时候执行的方法</li><li>catch(函数)：失败状态的时候执行的方法</li><li>finally(函数) ：结束时执行的方法，不管状态是成功还是失败，finally都会执行<br><strong>Promise 的调用方式 (链式调用)</strong></li><li>当在第一个then里面返回 一个新的promise对象的时候</li><li>可以在第一个then后面继续第二个then<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> time = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">2000</span> + <span class="number">2000</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(time);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (time &gt; <span class="number">3000</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功&#x27;</span>);</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败&#x27;</span>);</span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">&quot;reject&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 成功状态的时候执行</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">sa</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(sa);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 失败状态的时候执行</span></span><br><span class="line">p.<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">sc</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(sc);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>使用函数简单封装Promise代码<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fz</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> time = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">2000</span> + <span class="number">2000</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(time);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">3000</span>) &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(<span class="string">&quot;reject&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fz</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1成功&quot;</span>, num);</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2成功&quot;</span>, num);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;3成功&quot;</span>, num);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败&#x27;</span>, num);</span><br><span class="line">&#125;).<span class="title function_">finally</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;无论最终是成功还是失败，都会执行&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="二-Promise的静态方法"><a href="#二-Promise的静态方法" class="headerlink" title="二. Promise的静态方法"></a>二. Promise的静态方法</h2><h3 id="1-all"><a href="#1-all" class="headerlink" title="(1) all"></a>(1) all</h3><p><strong>语法</strong>：Promise.all([多个 Promise])<br><strong>作用</strong>：用于将多个 Promise 实例，包装成一个新的 Promise 实例，接受一个<strong>数组作为参数</strong>，只有数组里面的每个状态都变成resolve，则新的 Promise 实例状态才会变成resolve。</p><blockquote><p>如果结果都为resolve，所有成功结果以数组的方式返回。 只要有一个为reject，就返回reject</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fz1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> time = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">2000</span> + <span class="number">2000</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(time, <span class="string">&#x27;第一个请求&#x27;</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">3000</span>) &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(&#123; <span class="attr">code</span>: <span class="number">1</span>, <span class="attr">message</span>: <span class="string">&#x27;成功1&#x27;</span> &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(&#123; <span class="attr">code</span>: <span class="number">2</span>, <span class="attr">message</span>: <span class="string">&#x27;失败1&#x27;</span> &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, time)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fz2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> time = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">2000</span> + <span class="number">2000</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(time, <span class="string">&#x27;第二个请求&#x27;</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">3000</span>) &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(&#123; <span class="attr">code</span>: <span class="number">1</span>, <span class="attr">message</span>: <span class="string">&#x27;成功2&#x27;</span> &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(&#123; <span class="attr">code</span>: <span class="number">2</span>, <span class="attr">message</span>: <span class="string">&#x27;失败2&#x27;</span> &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, time)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fz3</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> time = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">2000</span> + <span class="number">2000</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(time, <span class="string">&#x27;第三个请求&#x27;</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">3000</span>) &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(&#123; <span class="attr">code</span>: <span class="number">1</span>, <span class="attr">message</span>: <span class="string">&#x27;成功3&#x27;</span> &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(&#123; <span class="attr">code</span>: <span class="number">2</span>, <span class="attr">message</span>: <span class="string">&#x27;失败3&#x27;</span> &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, time)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Promise</span></span><br><span class="line">    .<span class="title function_">all</span>([<span class="title function_">fz1</span>(), <span class="title function_">fz2</span>(), <span class="title function_">fz3</span>()])</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功&#x27;</span>, res))</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败&#x27;</span>, err))</span><br></pre></td></tr></table></figure><h3 id="2-race"><a href="#2-race" class="headerlink" title="(2) race"></a>(2) race</h3><p><strong>语法</strong>：Promise.race([多个promise])<br><strong>作用</strong>：将多个 Promise 实例，包装成一个新的 Promise 实例，接受一个数组作为参数，只要其中有一个实例率先改变状态，则整个的状态就跟着改变。</p><blockquote><p>返回最先改变状态的结果</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fz1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> time = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">2000</span> + <span class="number">2000</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(time, <span class="string">&#x27;第一个请求&#x27;</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">3000</span>) &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(&#123; <span class="attr">code</span>: <span class="number">1</span>, <span class="attr">message</span>: <span class="string">&#x27;成功1&#x27;</span> &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(&#123; <span class="attr">code</span>: <span class="number">2</span>, <span class="attr">message</span>: <span class="string">&#x27;失败1&#x27;</span> &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, time)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fz2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> time = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">2000</span> + <span class="number">2000</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(time, <span class="string">&#x27;第二个请求&#x27;</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">3000</span>) &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(&#123; <span class="attr">code</span>: <span class="number">1</span>, <span class="attr">message</span>: <span class="string">&#x27;成功2&#x27;</span> &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(&#123; <span class="attr">code</span>: <span class="number">2</span>, <span class="attr">message</span>: <span class="string">&#x27;失败2&#x27;</span> &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, time)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fz3</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> time = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">2000</span> + <span class="number">2000</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(time, <span class="string">&#x27;第三个请求&#x27;</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">3000</span>) &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(&#123; <span class="attr">code</span>: <span class="number">1</span>, <span class="attr">message</span>: <span class="string">&#x27;成功3&#x27;</span> &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(&#123; <span class="attr">code</span>: <span class="number">2</span>, <span class="attr">message</span>: <span class="string">&#x27;失败3&#x27;</span> &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, time)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Promise</span></span><br><span class="line">    .<span class="title function_">race</span>([<span class="title function_">fz1</span>(), <span class="title function_">fz2</span>(), <span class="title function_">fz3</span>()])</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功&#x27;</span>, res))</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败&#x27;</span>, err))</span><br></pre></td></tr></table></figure><h3 id="3-allSettled-ES2020新增"><a href="#3-allSettled-ES2020新增" class="headerlink" title="(3) allSettled (ES2020新增)"></a>(3) allSettled (ES2020新增)</h3><p><strong>语法</strong>：Promise.allSettle([多个promise])<br><strong>作用</strong>：方法接受一个数组作为参数，数组的每个成员都是一个 Promise 对象，并返回一个新的 Promise 对象。只有等到参数数组的所有 Promise 对象都发生状态变更（不管是fulfilled还是rejected），返回的 Promise 对象才会发生状态变更。<br><strong>简单理解</strong>就是：不管是成功还是失败，都会触发，并会把结果用数组的形式返回，数组里面放着每一个promise的结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> allSettled = <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([p1, p2, p3]);</span><br><span class="line">allSettled.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then:&#x27;</span>, res); <span class="comment">// 返回数组，数组里面有三个对象，对象里面区分成功和失败的值，状态是正常的。</span></span><br><span class="line">    <span class="comment">//status:resolve  value  /  status:reject reason</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res[<span class="number">0</span>].<span class="property">status</span>); <span class="comment">// fulfilled</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res[<span class="number">0</span>].<span class="property">value</span>); <span class="comment">// 1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res[<span class="number">1</span>].<span class="property">status</span>); <span class="comment">// rejected</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res[<span class="number">1</span>].<span class="property">reason</span>); <span class="comment">// 2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4-any-（ES2021新增）"><a href="#4-any-（ES2021新增）" class="headerlink" title="(4) any()（ES2021新增）"></a>(4) any()（ES2021新增）</h3><p><strong>语法</strong>：Promise.any([多个promise])<br><strong>作用</strong>：该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。Promise.any()不会因为某个 Promise 变成rejected状态而结束，必须等到所有参数 Promise 变成rejected状态才会结束。</p><blockquote><p>只要有一个成功就会返回成功，如果有多个成功值，返回最先成功的，如果全部都失败，返回：<code>AggregateError: All promises were rejected</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="comment">// resolve(&#x27;1&#x27;)</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// reject(&#x27;2&#x27;)</span></span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析：</span></span><br><span class="line"><span class="comment">// 如果遇到成功的请求，通过then返回resolve传递给then对应的值，如果都是失败的状态，最终走catch输出默认的字符( All promises were rejected),执行catch里面的代码，无法获取reject里面传入的值。</span></span><br><span class="line"><span class="keyword">let</span> any = <span class="title class_">Promise</span>.<span class="title function_">any</span>([p1, p2, p3]);</span><br><span class="line">any.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then:&#x27;</span>, res);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch代码&#x27;</span>); </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(msg); <span class="comment">//默认的字符All promises were rejected</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-Promise的其他方法"><a href="#5-Promise的其他方法" class="headerlink" title="(5) Promise的其他方法"></a>(5) Promise的其他方法</h3><p>以下两个方法主要是开发人员调试用的</p><ul><li>resolve()强行把promise的状态改为成功<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(num).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li>reject()强行把Promise的状态改为失败<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(num).<span class="title function_">then</span>().<span class="title function_">catch</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// 10</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="三-JavaScript容错处理"><a href="#三-JavaScript容错处理" class="headerlink" title="三. JavaScript容错处理"></a>三. JavaScript容错处理</h2><p>因为js代码如果出现错误，立刻停止，后续的代码不会执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// referenceError:a is not defined  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>所以需要采用方法使js代码出现错误时，不会影响到后续代码</p><h3 id="try…catch…"><a href="#try…catch…" class="headerlink" title="try…catch…"></a>try…catch…</h3><p><strong>语法1</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;执行代码&#125; <span class="keyword">catch</span> (err) &#123;执行代码&#125;</span><br></pre></td></tr></table></figure><p><strong>使用</strong>：<br>首先执行try里面的代码，如果不报错，catch不执行 如果报错，不会抛出错误，而是执行catch，把错误信息给到err。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123; <span class="comment">//e:try里面如果存在错误，e就是try里面的错误信息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e); <span class="comment">// referenceError:a is not defined  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这里是catch的输出&#x27;</span>); <span class="comment">// 这里是catch的输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;后面后续的代码输出&#x27;</span>); <span class="comment">// 后面后续的代码输出</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;后面后续的代码输出&#x27;</span>); <span class="comment">// 后面后续的代码输出</span></span><br></pre></td></tr></table></figure><p><strong>语法2</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;执行代码&#125; <span class="keyword">catch</span> (err) &#123;执行代码&#125; <span class="keyword">finally</span>&#123;执行代码&#125;</span><br></pre></td></tr></table></figure><p><strong>注</strong>：finally里面的语法不管是执行try还是catch，finally里面的代码一定会执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123; <span class="comment">//e:try里面如果存在错误，e就是try里面的错误信息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e); <span class="comment">// referenceError:a is not defined</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这里是catch的输出&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; <span class="comment">//收尾的工作，不再使用的对象，变量，设置null</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;finally一定会执行&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">    a</span></span><br><span class="line"><span class="comment">    finally一定会执行</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>应用场景-案例</strong><br>随机生成一个数字，添加判断条件，最终输出成功或失败结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fz</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> time = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">2000</span> + <span class="number">2000</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(time);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">2500</span>) &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(<span class="string">&quot;reject&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">cs</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> res1 = <span class="keyword">await</span> <span class="title function_">fz</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res1);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">const</span> res2 = <span class="keyword">await</span> <span class="title function_">fz</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">cs</span>()</span><br></pre></td></tr></table></figure><h2 id="四-利用promise封装ajax"><a href="#四-利用promise封装ajax" class="headerlink" title="四. 利用promise封装ajax"></a>四. 利用promise封装ajax</h2><p>封装前的分析：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        封装ajax </span></span><br><span class="line"><span class="comment">            function ajax(options)&#123;&#125;</span></span><br><span class="line"><span class="comment">        调用封装的ajax</span></span><br><span class="line"><span class="comment">            ajax(&#123;&#125;)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        分析</span></span><br><span class="line"><span class="comment">            封装方案</span></span><br><span class="line"><span class="comment">                1. 回调函数方式</span></span><br><span class="line"><span class="comment">                    - 将来使用的时候，可能会出现回调地狱</span></span><br><span class="line"><span class="comment">                2. promise </span></span><br><span class="line"><span class="comment">                    - 后面 then/catch</span></span><br><span class="line"><span class="comment">                    - 也可以用async/await</span></span><br><span class="line"><span class="comment">            参数</span></span><br><span class="line"><span class="comment">                1. 请求地址 url 必填</span></span><br><span class="line"><span class="comment">                2. 请求方式 method，选填（只允许 get post），要么不传，默认值 get</span></span><br><span class="line"><span class="comment">                3. 是否异步 async，选填  默认true</span></span><br><span class="line"><span class="comment">                4. 参数 data 选填，默认是&#x27;&#x27;, （允许传查询字符串 和 对象）</span></span><br><span class="line"><span class="comment">                5. 请求头headers 选填，默认&#123;content-type:&#x27;application/x-www-form-urlencoded&#x27;&#125;</span></span><br><span class="line"><span class="comment">                6. 是否解析响应的参数 dataType, 选填 默认是string,  选填 json</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>封装代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象格式转查询字符串格式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">queryString</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        str += <span class="string">`&amp;<span class="subst">$&#123;k&#125;</span>=<span class="subst">$&#123;obj[k]&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用闭包保存url基准地址</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createAjax</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置一个变量作为基准地址，并长期保存这个变量</span></span><br><span class="line">    <span class="keyword">let</span> baseUrl = url</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装ajax函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">options = &#123;&#125;</span>) &#123;</span><br><span class="line">        <span class="comment">// 1.验证参数格式</span></span><br><span class="line">        <span class="comment">// 1-1.验证url格式：必填</span></span><br><span class="line">        <span class="keyword">if</span> (!options.<span class="property">url</span>) &#123;</span><br><span class="line">            <span class="comment">// 没填抛出错误：&#x27;url必填&#x27;</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;url必填&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1-2.验证method：要么不写，要么get或post</span></span><br><span class="line">        <span class="keyword">if</span> (!(options.<span class="property">method</span> === <span class="literal">undefined</span> || <span class="regexp">/^(get|post)$/i</span>.<span class="title function_">test</span>(options.<span class="property">method</span>))) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请求方式支持get 和 post&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1-3.验证async：要么不写，要么true/false ===&gt; 参数是布尔类型</span></span><br><span class="line">        <span class="keyword">if</span> (!(options.<span class="property">async</span> === <span class="literal">undefined</span> || <span class="keyword">typeof</span> options.<span class="property">async</span> === <span class="string">&#x27;boolean&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;async需要一个布尔值&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1-4.验证data：要么不写，支持字符串格式/对象格式</span></span><br><span class="line">        <span class="keyword">if</span> (!(options.<span class="property">data</span> === <span class="literal">undefined</span> || <span class="keyword">typeof</span> options.<span class="property">data</span> === <span class="string">&#x27;string&#x27;</span> || <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(options.<span class="property">data</span>) === <span class="string">&#x27;[object Object]&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;data需要一个字符串格式或者对象格式&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1-5.验证headers：要么不写，要么是对象格式</span></span><br><span class="line">        <span class="keyword">if</span> (!(options.<span class="property">headers</span> === <span class="literal">undefined</span> || <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(options.<span class="property">headers</span>) === <span class="string">&#x27;[object Object]&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;headers需要一个对象格式&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1-6.验证dataType参数：要么不写，要么是string 或者 json </span></span><br><span class="line">        <span class="keyword">if</span> (!(options.<span class="property">dataType</span> === <span class="literal">undefined</span> || <span class="regexp">/^(string|json)$/</span>.<span class="title function_">test</span>(options.<span class="property">dataType</span>))) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;dataType 只能写 string json&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.准备一个默认值</span></span><br><span class="line">        <span class="keyword">const</span> _default = &#123;</span><br><span class="line">            <span class="comment">// 修改请求地址：基准地址+options.url</span></span><br><span class="line">            <span class="comment">// eg：options.url = /test/first</span></span><br><span class="line">            <span class="attr">url</span>: baseUrl + options.<span class="property">url</span>,</span><br><span class="line">            <span class="comment">// method只有三个选择（没写，get，post）</span></span><br><span class="line">            <span class="attr">method</span>: options.<span class="property">method</span> || <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">            <span class="comment">// async只有三个选择（没写，true，false）并且没写：默认值是true</span></span><br><span class="line">            <span class="comment">// 一个ES2020新的操作符 ??</span></span><br><span class="line">            <span class="comment">// ?? 空值运算符: 只有左边的是undefined或者null, 才使用右边的</span></span><br><span class="line">            <span class="attr">async</span>: options.<span class="property">async</span> ?? <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">// data只能有三个选择：字符串、对象、undefined，默认值是&#x27;&#x27;</span></span><br><span class="line">            <span class="attr">data</span>: options.<span class="property">data</span> || <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="comment">// headers只能是 undefined或者对象，默认是&#123;&#x27;content-type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;&#125;</span></span><br><span class="line">            <span class="attr">headers</span>: &#123; <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>, ...options.<span class="property">headers</span> &#125;,</span><br><span class="line">            <span class="comment">// 是否解析响应的参数 dataType, (选填) 默认是string,  (选填) json</span></span><br><span class="line">            <span class="attr">dataType</span>: options.<span class="property">dataType</span> || <span class="string">&#x27;string&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2-1.data可能是对象，如果是对象，需要转为查询字符串格式</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> _default.<span class="property">data</span> === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            _default.<span class="property">data</span> = <span class="title function_">queryString</span>(_default.<span class="property">data</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2-2.请求方式是get并且data有值，url需要拼接上刚刚转换的data</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/^get$/i</span>.<span class="title function_">test</span>(_default.<span class="property">method</span>) &amp;&amp; _default.<span class="property">data</span>) &#123;</span><br><span class="line">            _default.<span class="property">url</span> = _default.<span class="property">url</span> + <span class="string">&#x27;?&#x27;</span> + _default.<span class="property">data</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 创建ajax对象 按照promise方式</span></span><br><span class="line">        <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">            xhr.<span class="title function_">open</span>(_default.<span class="property">method</span>, _default.<span class="property">url</span>, <span class="literal">false</span>)</span><br><span class="line">            xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="comment">// 这里的xhr.readyState必然是4，onload是一个请求完成的事件</span></span><br><span class="line">                <span class="comment">// 如果请求成功，xhr状态码是4，http状态码是200-299 成功</span></span><br><span class="line">                <span class="comment">// 需求， 根据业务进一步封装，如果后端返回的内容中，code为1，成功，其他失败</span></span><br><span class="line">                <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; <span class="regexp">/^2\d&#123;2&#125;$/</span>.<span class="title function_">test</span>(xhr.<span class="property">status</span>)) &#123;</span><br><span class="line">                    <span class="keyword">let</span> res = xhr.<span class="property">responseText</span></span><br><span class="line">                    <span class="comment">// 根据服务端返回的内容判断</span></span><br><span class="line">                    <span class="comment">// 首先代码进入到这里，http请求成功，可以成功从服务端拿到响应内容</span></span><br><span class="line">                    <span class="comment">// 响应内容分两种情况，</span></span><br><span class="line">                    <span class="comment">// 一个是正确的</span></span><br><span class="line">                    <span class="comment">// 一个是业务错误 （参数不正确，代码错误，其他....）</span></span><br><span class="line">                    <span class="comment">// 根据后端返回的内容判断, code:1 正确的 成功</span></span><br><span class="line">                    <span class="comment">// code 不是1 错误（用户密码错误，登录时间过期 ）</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        res = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(res)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// 正确的：成功返回正确的数据 </span></span><br><span class="line">                        <span class="title function_">resolve</span>(&#123; <span class="attr">code</span>: <span class="number">1</span>, <span class="attr">message</span>: <span class="string">&quot;成功&quot;</span>, <span class="attr">data</span>: _default.<span class="property">dataType</span> === <span class="string">&#x27;string&#x27;</span> ? xhr.<span class="property">responseText</span> : res &#125;)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 错误：包括各种错误 </span></span><br><span class="line">                        <span class="title function_">resolve</span>(&#123; <span class="attr">code</span>: <span class="number">0</span>, <span class="attr">message</span>: <span class="string">&#x27;业务失败&#x27;</span>, <span class="attr">err</span>: res &#125;)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 请求不成功 -- 进入这里的代码必然是http状态码不是200-299的情况</span></span><br><span class="line">                    <span class="keyword">let</span> res = xhr.<span class="property">responseText</span></span><br><span class="line">                    <span class="title function_">resolve</span>(&#123; <span class="attr">code</span>: <span class="number">0</span>, <span class="attr">message</span>: <span class="string">&#x27;网络请求失败&#x27;</span>, <span class="attr">err</span>: res &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果post </span></span><br><span class="line">            <span class="keyword">if</span> (<span class="regexp">/^post$/i</span>.<span class="title function_">test</span>(_default.<span class="property">method</span>)) &#123;</span><br><span class="line">                xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;content-type&#x27;</span>, _default.<span class="property">headers</span>[<span class="string">&#x27;content-type&#x27;</span>])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果有token </span></span><br><span class="line">            <span class="keyword">if</span> (_default.<span class="property">headers</span>.<span class="property">authorization</span>) &#123;</span><br><span class="line">                xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;authorization&#x27;</span>, _default.<span class="property">headers</span>[<span class="string">&#x27;authorization&#x27;</span>])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是post 需要发送data</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="regexp">/^post$/i</span>.<span class="title function_">test</span>(_default.<span class="property">method</span>)) &#123;</span><br><span class="line">                xhr.<span class="title function_">send</span>(_default.<span class="property">data</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                xhr.<span class="title function_">send</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 把promise对象返回</span></span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回ajax函数</span></span><br><span class="line">    <span class="keyword">return</span> ajax</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置url基准地址</span></span><br><span class="line"><span class="keyword">let</span> ajax = <span class="title function_">createAjax</span>(<span class="string">&#x27;http://localhost:8888&#x27;</span>)</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.利用Promise的then()方法测试封装的ajax</span></span><br><span class="line"><span class="comment">// ajax(&#123;</span></span><br><span class="line"><span class="comment">//     url: &#x27;/test/first&#x27;,</span></span><br><span class="line"><span class="comment">// &#125;).then(res =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     console.log(res);</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.利用async await 测试封装的ajax</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">ajax</span>(&#123; <span class="attr">url</span>: <span class="string">&#x27;/goods/list&#x27;</span>, <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span> &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure><p><strong>注</strong>：测试前需要开启本地服务器<br>本地服务器下载地址：<a href="https://download.csdn.net/download/qq_45867247/87420764?spm=1001.2014.3001.5503">Ajax案例测试本地服务器-Node.js文档类资源-CSDN文库</a></p><h2 id="五-async和await"><a href="#五-async和await" class="headerlink" title="五. async和await"></a>五. async和await</h2><ol><li>async其实就是promise的语法糖。函数前面加一个async，函数里面异步操作的方法前加一个await关键字。<br> 顾名思义，await就是让你等一下，执行完了再继续往下走。<br> <strong>注意</strong>：await只能在async函数中执行，否则会报错。<br> <strong>目的</strong>：让异步代码像同步代码一样执行。</li><li>async:异步的意思，作用是申明一个异步函数，函数的返回值是promise 对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn1</span>()); <span class="comment">//async函数隐式返回一个promise对象</span></span><br></pre></td></tr></table></figure></li><li>await:等待<br> await是async+wait的结合 即异步等待，async和await 二者必须是结合着使用。<br> <strong>注</strong>：匿名函数也可以使用async和await<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">!<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> h = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(h); <span class="comment">//hello  证明await就是promise里面then的语法糖。</span></span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">Promise是**ES6 新增**的特性**目的**：用来解决异步解决回调地狱问题</summary>
    
    
    
    <category term="前端" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="RequestData" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/RequestData/"/>
    
    
    <category term="RequestData" scheme="https://fanxing28.github.io/tags/RequestData/"/>
    
  </entry>
  
  <entry>
    <title>Ajax 基础知识</title>
    <link href="https://fanxing28.github.io/2023/12/14/%E5%89%8D%E7%AB%AF/RequestData/Ajax%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://fanxing28.github.io/2023/12/14/%E5%89%8D%E7%AB%AF/RequestData/Ajax%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2023-12-14T13:55:00.000Z</published>
    <updated>2023-12-14T14:56:23.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概念"><a href="#一-概念" class="headerlink" title="一. 概念"></a>一. 概念</h2><p>AJAX （ Asynchronous JavaScript and XML）是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。<br><strong>注</strong>：前后端交互只能使用字符串<br><strong>AJAX 的优势</strong></p><ol><li>不需要插件的支持，原生 js 就可以使用。</li><li>用户体验好（不需要刷新页面就可以更新数据）。</li><li>减轻服务端和带宽的负担。<br><strong>最大的优点</strong>是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。<br><strong>缺点</strong>： 搜索引擎的支持度不够，因为数据都不在页面上，搜索引擎搜索不到。</li></ol><h2 id="二-Ajax-请求的步骤"><a href="#二-Ajax-请求的步骤" class="headerlink" title="二. Ajax 请求的步骤"></a>二. Ajax 请求的步骤</h2><p><strong>Ajax 四部曲与后端进行交互</strong>：</p><ol><li>创建XMLHttpRequest实例对象;</li><li>配置请求信息，使用open方法与服务器建立链接;</li><li>向服务器发送数据，进行解析;</li><li>在回调函数中针对不同的响应状态进行处理;</li></ol><h3 id="1-创建XMLHttpRequest对象"><a href="#1-创建XMLHttpRequest对象" class="headerlink" title="1. 创建XMLHttpRequest对象"></a>1. 创建XMLHttpRequest对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(xhr); <span class="comment">// XMLHttpRequest&amp;nbsp;&#123;onreadystatechange: null, readyState: 0, timeout: 0, withCredentials: false, upload: XMLHttpRequestUpload,&amp;nbsp;…&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-配置请求信息，使用open方法与服务器建立链接"><a href="#2-配置请求信息，使用open方法与服务器建立链接" class="headerlink" title="2. 配置请求信息，使用open方法与服务器建立链接"></a>2. 配置请求信息，使用open方法与服务器建立链接</h3><p><strong>语法</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(method, url, <span class="keyword">async</span>);</span><br></pre></td></tr></table></figure><ul><li>第一个参数：请求方式（get、post、put、delete…）常用的是get和post</li><li>第二个参数：请求地址</li><li>第三个参数：是否异步（<strong>true:异步（默认）</strong>，false:同步）<blockquote><p>XMLHttpRequest 对象如果要用于 AJAX 的话，其 open() 方法的 async 参数必须设置为 true</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eg:</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://localhost:8888/test/first&#x27;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-向服务器发送数据，进行解析"><a href="#3-向服务器发送数据，进行解析" class="headerlink" title="3. 向服务器发送数据，进行解析"></a>3. 向服务器发送数据，进行解析</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure><h3 id="4-在回调函数中针对不同的响应状态进行处理"><a href="#4-在回调函数中针对不同的响应状态进行处理" class="headerlink" title="4. 在回调函数中针对不同的响应状态进行处理"></a>4. 在回调函数中针对不同的响应状态进行处理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// onload页面加载完成，相当于AJAX的状态码：readState === 4时</span></span><br></pre></td></tr></table></figure><p><strong>XMLHttpRequest.responseText</strong>： 在一个请求被发送后，从服务器端返回文本。<br><strong>readystatechange事件</strong>：当就绪状态码发生改变时触发</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-Ajax-状态码"><a href="#三-Ajax-状态码" class="headerlink" title="三. Ajax 状态码"></a>三. Ajax 状态码</h2><p><strong>语法</strong>：xhr.readyState：就绪状态码，通过数字表达解析过程是否完成。</p><ul><li><code>readyState === 0</code>：请求未初始化<blockquote><p>也就是XMLHttpRequest对象创建成功，但open()方法还没有执行</p></blockquote></li><li><code>readyState === 1</code>：配置本次请求信息成功<blockquote><p>也就是服务器连接已建立(已调用open方法，但还未调用send)</p></blockquote></li><li><code>readyState === 2</code>：请求已接收(已调用send方法)<blockquote><p>也就是请求已经成功，响应数据还没有解析好</p></blockquote></li><li><code>readyState === 3</code>：请求处理中(请求已到达服务端，正在处理)<blockquote><p>也就是浏览器正在解析本次响应，还没有完成</p></blockquote></li><li><code>readyState === 4</code>：请求已完成，且响应已就绪<blockquote><p>也就是浏览器解析响应完成，可以使用responseText（可以在客户端使用了）</p></blockquote></li></ul><p><strong>注</strong>：<code>readyState === 2\3\4</code> 都可以认为是请求成功</p><h2 id="四-Ajax-请求方式"><a href="#四-Ajax-请求方式" class="headerlink" title="四. Ajax 请求方式"></a>四. Ajax 请求方式</h2><h3 id="1-常见的请求方式"><a href="#1-常见的请求方式" class="headerlink" title="(1) 常见的请求方式"></a>(1) 常见的请求方式</h3><ul><li>GET 偏向于获取的语义</li><li>POST 偏向于发送的语义</li><li>PUT 偏向于提交的语义（提交保存）</li><li>PATCH 偏向于提交的语义（提交修改）</li><li>DELETE 偏向于删除的语义</li><li>HEAD 偏向于获取响应头信息</li><li>OPTIONS 偏向于获取服务器的信息</li><li>CONNECT 保留方式</li><li>…<br><strong>最常见的请求方式</strong>：</li><li>GET</li><li>POST</li></ul><h3 id="2-GET和POST区别"><a href="#2-GET和POST区别" class="headerlink" title="(2) GET和POST区别"></a>(2) GET和POST区别</h3><ol><li>携带参数的位置<blockquote><p>get：直接写地址栏后面<br>post：在请求体中书写</p></blockquote></li><li>携带参数的大小<blockquote><p>get：2kb左右<br>post：原则上没有大小限制，服务器可以限制</p></blockquote></li><li>携带参数的格式<blockquote><p>get：只允许携带查询字符串格式<br>post：原则上不限制格式，但是要在请求报文（content-type）中约定</p></blockquote></li><li>安全<blockquote><p>get：明文发送，相对不安全<br>post：暗文发送，相对安全</p></blockquote></li></ol><h3 id="3-使用GET请求发送数据"><a href="#3-使用GET请求发送数据" class="headerlink" title="(3) 使用GET请求发送数据"></a>(3) 使用GET请求发送数据</h3><p>使用GET请求发送数据时，将数据通 过 ? 和 &amp; 符号拼接在地址栏的后面（安全性不高，地址栏可见）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span> 年龄：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;age&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> <span class="attr">id</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    submit.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 发送请求数据（使用get方式请求，数据用?拼接在地址栏后面）</span></span></span><br><span class="line"><span class="language-javascript">        xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>, <span class="string">`http://localhost:8888/test/third?name=<span class="subst">$&#123;username.value&#125;</span>&amp;age=<span class="subst">$&#123;age.value&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">        xhr.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript">        xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(xhr.<span class="property">responseText</span>));</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-使用POST请求发送数据"><a href="#4-使用POST请求发送数据" class="headerlink" title="(4) 使用POST请求发送数据"></a>(4) 使用POST请求发送数据</h3><p>使用POST方式请求数据时，将数据放置在send()方法里面发送给后端，多条数据通过&amp;符号进行拼接。并且必须设置请求头（固定格式）才能发送，安全性比较好。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span> 年龄：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;age&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> <span class="attr">id</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    submit.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">        xhr.<span class="title function_">open</span>(<span class="string">&#x27;post&#x27;</span>, <span class="string">`http://localhost:8888/test/fourth`</span>);</span></span><br><span class="line"><span class="language-javascript">        xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>); <span class="comment">// 设置请求头固定，发送内容类型</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 使用POST方式发送请求数据通过send()方法发送</span></span></span><br><span class="line"><span class="language-javascript">        xhr.<span class="title function_">send</span>(<span class="string">`name=<span class="subst">$&#123;username.value&#125;</span>&amp;age=<span class="subst">$&#123;age.value&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">        xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(xhr.<span class="property">responseText</span>));</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="五-同步和异步"><a href="#五-同步和异步" class="headerlink" title="五. 同步和异步"></a>五. 同步和异步</h2><p>javascript是单线程的，只有一个主线程，一次只能执行一个任务，同步和异步指的就是在线程上面执行代码的顺序。</p><ol><li><strong>同步</strong>：阻塞模式，后一个任务必须等到前一个任务完成才执行，顺序执行，主线程上面的任务。</li><li><strong>异步</strong>：非阻塞模式，异步任务先进入队列等候，等到主线程上面的任务完成，才被通知执行。定时器就是异步的。<br><strong>Ajax的异步操作</strong><br>准确的说：定时器异步指的是定时器里面的回调函数。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>); <span class="comment">//同步</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>); <span class="comment">//同步</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;http://localhost:8888/goods/list&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>); <span class="comment">//同步</span></span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>); <span class="comment">//同步</span></span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">//异步</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">// console.log(xhr.responseText);</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">7</span>); <span class="comment">//同步</span></span><br><span class="line"><span class="comment">// 上述的代码依次输出的结果为：1 2 3 4 7 5 6</span></span><br><span class="line"><span class="comment">// 上面的代码证明ajax监听事情是异步的，第四步是异步的。</span></span><br></pre></td></tr></table></figure>所以在平时使用时经常将第三步和第四步进行位置的调换：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eg:</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;http://localhost:8888/goods/list&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">//异步,最后</span></span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure>这样交换之后就可以不用判断请求是异步还是同步了。</li></ol><h2 id="六-案例测试"><a href="#六-案例测试" class="headerlink" title="六. 案例测试"></a>六. 案例测试</h2><p><strong>接口文档</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.1</span> 测试请求<span class="number">1</span></span><br><span class="line">  <span class="number">2.1</span><span class="number">.1</span> 请求地址</span><br><span class="line">  &gt; <span class="string">`/test/first`</span></span><br><span class="line">  <span class="number">2.1</span><span class="number">.2</span> 请求方式</span><br><span class="line">  &gt; <span class="string">`get`</span></span><br><span class="line">  <span class="number">2.1</span><span class="number">.3</span> 携带参数</span><br><span class="line">  &gt; 无</span><br><span class="line">  <span class="number">2.1</span><span class="number">.4</span> 响应数据</span><br><span class="line">  &gt; 哇塞, 你已经成功使用 ajax 发送给我了一个请求, 这是我给你的回应, 我是一个字符串类型 ^_^ !</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eg:</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&quot;http://localhost:8888/test/first&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">readyState</span>);</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;状态码&#x27;</span>, xhr.<span class="property">readyState</span>);</span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.<span class="title function_">send</span>(); <span class="comment">// 哇塞, 你已经成功使用 ajax 发送给我了一个请求, 这是我给你的回应, 我是一个字符串类型 ^_^ !</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">AJAX （ Asynchronous JavaScript and XML）是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</summary>
    
    
    
    <category term="前端" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="RequestData" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/RequestData/"/>
    
    
    <category term="RequestData" scheme="https://fanxing28.github.io/tags/RequestData/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 传输协议</title>
    <link href="https://fanxing28.github.io/2023/12/14/%E5%89%8D%E7%AB%AF/RequestData/HTTP%20%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/"/>
    <id>https://fanxing28.github.io/2023/12/14/%E5%89%8D%E7%AB%AF/RequestData/HTTP%20%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/</id>
    <published>2023-12-14T13:48:00.000Z</published>
    <updated>2023-12-14T14:56:23.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-协议过程"><a href="#一-协议过程" class="headerlink" title="一. 协议过程"></a>一. 协议过程</h2><h3 id="1-建立连接"><a href="#1-建立连接" class="headerlink" title="1. 建立连接"></a>1. 建立连接</h3><blockquote><p>浏览器和服务器进行连接</p></blockquote><ul><li>基于 TCP&#x2F;IP 协议 的三次握手</li></ul><h3 id="2-发送请求"><a href="#2-发送请求" class="headerlink" title="2. 发送请求"></a>2. 发送请求</h3><ul><li>要求：前端必须以请求报文的形式发送</li><li>报文：由浏览器组装，只需要提供对应的信息就可以</li><li>报文包含的内容：</li></ul><ol><li>请求报文行<br> 请求方式 请求地址 传输协议</li><li>请求报文头 (本次请求的一些说明信息)</li><li>请求报文空行</li><li>请求报文体 (携带数据)</li></ol><h3 id="3-接受响应"><a href="#3-接受响应" class="headerlink" title="3. 接受响应"></a>3. 接受响应</h3><ul><li>要求后端必须用响应报文的形式返回</li><li>报文用服务器组装</li><li>报文包含的内容</li></ul><ol><li>响应报文行<blockquote><p>响应状态码</p></blockquote></li><li>响应报文头 （本次响应的一些说明信息）<blockquote><p>server 那个服务器返回的信息 date 时间 content-length 响应体长度 content-type 响应体数据类型 …</p></blockquote></li><li>响应报问题<blockquote><p>后端返回前端的信息</p></blockquote></li></ol><h3 id="4-断开连接"><a href="#4-断开连接" class="headerlink" title="4. 断开连接"></a>4. 断开连接</h3><blockquote><p>浏览器和服务器断开连接</p></blockquote><ul><li>基于 TCP&#x2F;IP 协议的四次挥手</li></ul><h2 id="二-响应状态码"><a href="#二-响应状态码" class="headerlink" title="二. 响应状态码"></a>二. 响应状态码</h2><p><strong>HTTP响应状态码</strong>用以表示网页服务器超文本传输协议响应状态的3位数字代码,通过3位的数字代码确定这次的意义。<br>由3位数字和原因短语组成。数字中的第一位指定了响应类别，后两位无分类。相应类别由以下五种：</p><table><thead><tr><th>状态码</th><th>类别</th><th>描述</th></tr></thead><tbody><tr><td>1xx</td><td>Informational（信息状态码）</td><td>接受请求正在处理</td></tr><tr><td>2xx</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3xx</td><td>Redirection（重定向状态码）</td><td>需要附加操作已完成请求</td></tr><tr><td>4xx</td><td>Client Error（客户端错误状态码）</td><td>服务器无法处理请求</td></tr><tr><td>5xx</td><td>Server Error（服务器错误状态码）</td><td>服务器处理请求出错</td></tr><tr><td><strong>常见的http响应状态码</strong>：</td><td></td><td></td></tr></tbody></table><table><thead><tr><th>状态码</th><th>状态码英文名称</th><th>中文描述</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td><code>请求成功</code>。一般用于GET与POST请求</td></tr><tr><td>204</td><td>No Content</td><td>无内容。<code>服务器成功处理，但未返回内容</code>。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td>301</td><td>Moved Permanently</td><td><code>永久性重定向</code>。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td>302</td><td>Found</td><td><code>临时性重定向</code>。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td>401</td><td>Unauthorized</td><td><code>请求要求用户的身份认证</code>，通过HTTP认证（BASIC认证，DIGEST认证）的认证信息，若之前已进行过一次请求，则表示用户认证失败</td></tr><tr><td>403</td><td>Forbidden</td><td><code>服务器理解请求客户端的请求，但是拒绝执行此请求</code></td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面。也可以在服务器拒绝请求且不想说明理由时使用</td></tr><tr><td>503</td><td>Service Unavailable</td><td><code>由于超载或系统维护，服务器暂时的无法处理客户端的请求</code>。延时的长度可包含在服务器的Retry-After头信息中</td></tr></tbody></table><h2 id="三-TCP-三次握手和四次挥手"><a href="#三-TCP-三次握手和四次挥手" class="headerlink" title="三.TCP 三次握手和四次挥手"></a>三.TCP 三次握手和四次挥手</h2><h3 id="1-三次握手讲解"><a href="#1-三次握手讲解" class="headerlink" title="(1) 三次握手讲解"></a>(1) 三次握手讲解</h3><ol><li>客户端发送位码为syn＝1,随机产生seq number&#x3D;1234567的数据包到服务器，服务器由SYN&#x3D;1知道客户端要求建立联机（<strong>客户端：我要连接你</strong>）</li><li>服务器收到请求后要确认联机信息，向A发送ack number&#x3D;(客户端的seq+1),syn&#x3D;1,ack&#x3D;1,随机产生seq&#x3D;7654321的包（<strong>服务器：好的，你来连吧</strong>）</li><li>客户端收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，客户端会再发送ack number&#x3D;(服务器的seq+1),ack&#x3D;1，服务器收到后确认seq值与ack&#x3D;1则连接建立成功。（<strong>客户端：好的，我来了</strong>）</li></ol><h3 id="2-为什么http建立连接需要三次握手，不是两次或四次"><a href="#2-为什么http建立连接需要三次握手，不是两次或四次" class="headerlink" title="(2) 为什么http建立连接需要三次握手，不是两次或四次?"></a>(2) 为什么http建立连接需要三次握手，不是两次或四次?</h3><p><strong>答：三次是最少的安全次数，两次不安全，四次浪费资源；</strong></p><h3 id="3-TCP关闭连接过程"><a href="#3-TCP关闭连接过程" class="headerlink" title="(3) TCP关闭连接过程"></a>(3) TCP关闭连接过程</h3><ol><li>Client向Server发送FIN包，表示Client主动要关闭连接，然后进入FIN_WAIT_1状态，等待Server返回ACK包。此后Client不能再向Server发送数据，但能读取数据。</li><li>Server收到FIN包后向Client发送ACK包，然后进入CLOSE_WAIT状态，此后Server不能再读取数据，但可以继续向Client发送数据。</li><li>Client收到Server返回的ACK包后进入FIN_WAIT_2状态，等待Server发送FIN包。</li><li>Server完成数据的发送后，将FIN包发送给Client，然后进入LAST_ACK状态，等待Client返回ACK包，此后Server既不能读取数据，也不能发送数据。</li><li>Client收到FIN包后向Server发送ACK包，然后进入TIME_WAIT状态，接着等待足够长的时间（2MSL）以确保Server接收到ACK包，最后回到CLOSED状态，释放网络资源。</li><li>Server收到Client返回的ACK包后便回到CLOSED状态，释放网络资源。</li></ol><h3 id="4-为什么要四次挥手？"><a href="#4-为什么要四次挥手？" class="headerlink" title="(4) 为什么要四次挥手？"></a>(4) 为什么要四次挥手？</h3><p>TCP是全双工信道，何为全双工就是客户端与服务端建立两条通道，通道1:客户端的输出连接服务端的输入；通道2:客户端的输入连接服务端的输出。两个通道可以同时工作：客户端向服务端发送信号的同时服务端也可以向客户端发送信号。所以关闭双通道的时候就是这样：<br>四次挥手的简单案例对话：</p><blockquote><p>客户端：我要关闭输入通道了。 服务端：好的，你关闭吧，我这边也关闭这个通道。</p></blockquote><p>服务端：我也要关闭输入通道了。 客户端：好的你关闭吧，我也把这个通道关闭。</p>]]></content>
    
    
    <summary type="html">HTTP 传输协议</summary>
    
    
    
    <category term="前端" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="RequestData" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/RequestData/"/>
    
    
    <category term="RequestData" scheme="https://fanxing28.github.io/tags/RequestData/"/>
    
  </entry>
  
  <entry>
    <title>Pinia (Vue的专属状态管理库)</title>
    <link href="https://fanxing28.github.io/2023/12/13/%E5%89%8D%E7%AB%AF/Vue/Pinia%20(Vue%E7%9A%84%E4%B8%93%E5%B1%9E%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%BA%93)/"/>
    <id>https://fanxing28.github.io/2023/12/13/%E5%89%8D%E7%AB%AF/Vue/Pinia%20(Vue%E7%9A%84%E4%B8%93%E5%B1%9E%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%BA%93)/</id>
    <published>2023-12-13T14:57:00.000Z</published>
    <updated>2023-12-14T14:56:23.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>与 Vuex 相比，Pinia 优点：</p><ul><li>不仅提供了一个更简单的 API</li><li>也提供了符合组合式 API 风格的 API</li><li>最重要的是，搭配 TypeScript 一起使用时有非常可靠的类型推断支持。<br>具体优势：</li></ul><ol><li>增加了组合式api的语法</li><li>少了一个mutations的概念，直接通过actions来修改数据</li><li>自带了模块化</li><li>更好的ts的支持</li><li>修改数据可以不借助于函数，就可以直接在组件修改</li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>用你喜欢的包管理器安装 <code>pinia</code>：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn add pinia</span><br><span class="line"># 或者使用 npm</span><br><span class="line">npm install pinia</span><br></pre></td></tr></table></figure><h2 id="选项式API使用"><a href="#选项式API使用" class="headerlink" title="选项式API使用"></a>选项式API使用</h2><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>1.用definedStore方法来创建仓库</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; defineStore &#125; from &#x27;pinia&#x27;</span><br></pre></td></tr></table></figure><p>2.你可以对 <code>defineStore()</code> 的返回值进行任意命名，但最好使用 store 的名字，同时<strong>以 <code>use</code> 开头且以 <code>Store</code> 结尾</strong>。(比如 <code>useUserStore</code>，<code>useCartStore</code>)<br><strong>第一个参数是你的应用中 Store 的唯一 ID</strong>。</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// useCounterStore表示一个模块化的仓库 </span><br><span class="line">// 第一个参数是模块名称 </span><br><span class="line">// 第二个参数可以是（选项式语法），也可以是函数（组合式语法） </span><br><span class="line">export const useCounterStore = defineStore(&#x27;counter&#x27;,&#123; state()&#123; return&#123; count: 3 &#125; &#125; &#125;)</span><br></pre></td></tr></table></figure><p>组件中使用：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plain Text</span><br></pre></td></tr></table></figure><h3 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示仓库的计算属性 getters: &#123; doubleCount(state) &#123; return state.count * 2 &#125; &#125;,</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span> <span class="attr">computed</span>: &#123; …<span class="title function_">mapGetters</span>(useCounterStore, [<span class="string">&#x27;doubleCount&#x27;</span>]) &#125;,</span><br></pre></td></tr></table></figure><h3 id="修改pinia中state的值"><a href="#修改pinia中state的值" class="headerlink" title="修改pinia中state的值"></a>修改pinia中state的值</h3><p><strong>方式一</strong>：直接在组件中进行修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapWritableState &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span> <span class="attr">computed</span>: &#123; …<span class="title function_">mapWritableState</span>(useCounterStore, [<span class="string">&#x27;count&#x27;</span>]), &#125;, <span class="attr">methods</span>: &#123; <span class="title function_">fn</span>(<span class="params"></span>) &#123; <span class="variable language_">this</span>.<span class="property">count</span>++ &#125;, &#125;</span><br></pre></td></tr></table></figure><p><strong>方式二</strong>：也可以通过actions的函数去进行修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// actions是用来改变仓库数据的 // actions里面是可以直接写异步的，快照是在数据改变的时候产生的 actions: &#123; increment() &#123; this.count++ &#125; &#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123; <span class="title function_">fn</span>(<span class="params"></span>) &#123; <span class="variable language_">this</span>.<span class="title function_">increment</span>() &#125;, …<span class="title function_">mapActions</span>(useCounterStore, [<span class="string">&#x27;increment&#x27;</span>]) &#125;</span><br></pre></td></tr></table></figure><h3 id="state-兼容-TS"><a href="#state-兼容-TS" class="headerlink" title="state 兼容 TS"></a>state 兼容 TS</h3><p>你并不需要做太多努力就能使你的 state 兼容 TS。 Pinia 会自动推断出你的 state 的类型，但在一些情况下，你得用一些方法来帮它一把。</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const useStore = defineStore(&#x27;storeId&#x27;, &#123; state: () =&gt; &#123; return &#123; // 用于初始化空列表 userList: [] as UserInfo[], // 用于尚未加载的数据 user: null as UserInfo | null, &#125; &#125;, &#125;)</span><br><span class="line">interface UserInfo &#123; name: string age: number &#125;</span><br></pre></td></tr></table></figure><p>如果你愿意，你可以用一个接口定义 state，并添加 <code>state()</code> 的返回值的类型。</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface State &#123; userList: UserInfo[] user: UserInfo | null &#125;</span><br><span class="line">const useStore = defineStore(&#x27;storeId&#x27;, &#123; state: (): State =&gt; &#123; return &#123; userList: [], user: null, &#125; &#125;, &#125;)</span><br><span class="line">interface UserInfo &#123; name: string age: number &#125;</span><br></pre></td></tr></table></figure><h2 id="组合式API使用"><a href="#组合式API使用" class="headerlink" title="组合式API使用"></a>组合式API使用</h2><p>在 <em>Setup Store</em> 中：</p><ul><li><code>ref()</code> 就是 <code>state</code> 属性</li><li><code>computed()</code> 就是 <code>getters</code></li><li><code>function()</code> 就是 <code>actions</code></li></ul><h3 id="定义数据"><a href="#定义数据" class="headerlink" title="定义数据"></a>定义数据</h3><p>组合式的语法的第二个参数要写成函数<br>仓库里面要<strong>定义数据</strong>的时候，使用ref</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span> </span><br><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useNewStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;new&#x27;</span>, <span class="function">() =&gt;</span> &#123; <span class="keyword">const</span> newName = <span class="title function_">ref</span>(<span class="string">&#x27;头条&#x27;</span>) <span class="keyword">const</span> num = <span class="title function_">ref</span>(<span class="number">5</span>) &#125;)</span><br></pre></td></tr></table></figure><p><strong>组件中使用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useNewStore &#125; <span class="keyword">from</span> <span class="string">&#x27;@/stores/new&#x27;</span> <span class="keyword">const</span> newStore = <span class="title function_">useNewStore</span>()</span><br></pre></td></tr></table></figure><h3 id="修改定义的数据"><a href="#修改定义的数据" class="headerlink" title="修改定义的数据"></a>修改定义的数据</h3><p><strong>方式一：直接在函数中修改</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; &#123; <span class="comment">// 修改数据的时候，可以直接对仓库数据进行修改 newStore.num++ &#125;</span></span><br></pre></td></tr></table></figure><p><strong>方式二：使用$patch</strong><br><strong>对象形式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; &#123; <span class="comment">// 使用$patch方式一次性修改多个变量 newStore.$patch(&#123; newName: &#x27;每日&#x27;, num: 20 &#125;) &#125;</span></span><br></pre></td></tr></table></figure><p><strong>函数形式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; &#123; newStore.$patch(<span class="function"><span class="params">state</span> =&gt;</span> &#123; state.<span class="property">newName</span> = <span class="string">&#x27;每日&#x27;</span> state.<span class="property">num</span> = state.<span class="property">num</span>++ &#125;) &#125;</span><br></pre></td></tr></table></figure><p><strong>方式三：使用actions</strong><br>actions的东西，直接定义函数就行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">changenum</span> = (<span class="params">n: number</span>) =&gt; &#123; num.<span class="property">value</span> *= n &#125;</span><br></pre></td></tr></table></figure><p>还可以通过actions的函数来修改仓库数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; &#123; newStore.<span class="title function_">changenum</span>(<span class="number">3</span>) &#125;</span><br></pre></td></tr></table></figure><p>里面可以直接写异步</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">changenum</span> = (<span class="params">n: number</span>) =&gt; &#123; <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; num.<span class="property">value</span> *= n &#125;, <span class="number">2000</span>) &#125; <span class="keyword">return</span> &#123; newName, num, doubleNum, changenum &#125;</span><br></pre></td></tr></table></figure><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>getters的东西，可以直接使用computed方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doubleNum = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> num.<span class="property">value</span> * <span class="number">2</span> &#125;)</span><br></pre></td></tr></table></figure><h3 id="subscribe-订阅-Action"><a href="#subscribe-订阅-Action" class="headerlink" title="$subscribe (订阅 Action)"></a>$subscribe (订阅 Action)</h3><p>对仓库的监听，只要仓库数据发生改变，回调函数就会自动调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newStore.$subscribe(<span class="function">(<span class="params">mutation, state</span>) =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(mutation) <span class="variable language_">console</span>.<span class="title function_">log</span>(state) <span class="comment">// 每当状态发生改变时，将整个state持久化到本地存储 // localStorage.getItem(&#x27;cart&#x27;,JSON.stringify(state)) &#125;)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Pinia (Vue的专属状态管理库)</summary>
    
    
    
    <category term="前端" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
    <category term="Vue" scheme="https://fanxing28.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue3 组合式API</title>
    <link href="https://fanxing28.github.io/2023/12/13/%E5%89%8D%E7%AB%AF/Vue/Vue3%20%E7%BB%84%E5%90%88%E5%BC%8FAPI/"/>
    <id>https://fanxing28.github.io/2023/12/13/%E5%89%8D%E7%AB%AF/Vue/Vue3%20%E7%BB%84%E5%90%88%E5%BC%8FAPI/</id>
    <published>2023-12-13T14:53:00.000Z</published>
    <updated>2023-12-14T14:56:23.664Z</updated>
    
    <content type="html"><![CDATA[<p><strong>特点</strong>：功能聚合，逻辑复用</p><h2 id="setup-函数"><a href="#setup-函数" class="headerlink" title="setup 函数"></a>setup 函数</h2><ul><li>组合式API<strong>只有一个选项setup函数</strong></li><li>setup是组合式api的入口，同时也是生命周期，没有this</li><li>每一个setup最后都需要return一个对象<blockquote><p>在template中使用的变量才需要return</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">      state.<span class="property">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不要忘记同时暴露 increment 函数</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      state,</span><br><span class="line">      increment</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>组合式api在template里面几乎没有任何区别</strong></li></ul><h2 id="响应式基础（ref，reactive）"><a href="#响应式基础（ref，reactive）" class="headerlink" title="响应式基础（ref，reactive）"></a>响应式基础（ref，reactive）</h2><p>如果需要<strong>响应式</strong>，要从vue里面解构ref或reactive函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref,reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">const</span> list = <span class="title function_">reactive</span>([ <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        count,</span><br><span class="line">        list</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>reactive用于创建响应式数据</li><li>ref也是用于创建响应式数据</li></ul><p>一般情况下使用ref比较多，在表单里面使用reactive比较多(一个表单需要绑定多个变量)</p><ul><li>如果希望一次性定义多个变量，建议使用reactive</li><li>如果希望一个一个的定义变量，建议使用ref<br><strong>reactive和ref使用场景总结</strong>：</li></ul><ol><li>ref 多用来定义基本数据类型（也可以定义对象，内部会自动通过 reactive 转为代理对象），而 reactive 只能用来定义对象数组类型</li><li><strong>ref 操作数据需要 .value</strong>，reactive 操作数据不需要 .value</li><li>ref 通过 Object.defineProperty() 的 get和 set 来实现响应式， reactive 通过 Proxy 来实现响应式，并通过 Reflect 操作源对象内部的数据<br>对于引用类型，什么时候用 ref，什么时候用 reactive？简单说，如果你只打算修改引用类型的一个属性，那么推荐用 reactive，如果你打算变量重新赋值，那么一定要用 ref。</li></ol><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>computed函数用于做计算属性，使用前需要从vue中解构出来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>computed执行的时候，<strong>里面传入一个回调函数</strong></li><li>回调函数<strong>需要return,</strong> 有一个返回值，返回值就是可以用的计算属性</li></ul><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>直接在setup中编写函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">warn</span>(<span class="params">message, event</span>) &#123;</span><br><span class="line">  <span class="comment">// 这里可以访问原生事件</span></span><br><span class="line">  <span class="keyword">if</span> (event) &#123;</span><br><span class="line">    event.<span class="title function_">preventDefault</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">alert</span>(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul><li>使用前需要先从vue中解构出来<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br></pre></td></tr></table></figure></li><li>变成函数(<strong>可以多次调用</strong>)，要<strong>传入一个回调函数作为参数</strong></li><li>将beforeCreate和created删除，如果还想用可以直接在setup里面写</li><li>其他生命周期前面全部加上on<br>Vue2选项式API 和 Vue3组合式API的<strong>区别</strong>：</li><li>Vue2选项式API(option api) <strong>优点</strong>：简单，各选项各司其职； <strong>缺点</strong>：不方便功能复用、功能代码分散、维护代码横跳</li><li>Vue3组合式API(composition api) <strong>优点</strong>：功能代码组合维护, 方便功能复用；</li></ul><h2 id="watch-监听"><a href="#watch-监听" class="headerlink" title="watch 监听"></a>watch 监听</h2><p><strong>作用</strong>：用于数据监听<br><strong>参数</strong>：至少要有两个参数</p><ol><li>要监听的数据</li><li>数据改变以后的回调函数，回调函数又可以有两个参数</li><li>val（改变前的值）</li><li>oldVal（改变后的值）</li><li>允许接受<strong>第三个参数</strong>（描述对象：{immediate:true…}）<br><strong>最主要应用场景</strong>：监听input框的改变，重新发起请求<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; watch, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">          <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">3</span>);</span><br><span class="line">      <span class="title function_">watch</span>(count,<span class="function">(<span class="params">val, oldVal</span>)=&gt;</span>&#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;count 改变了&quot;</span>)   </span><br><span class="line">      &#125;,&#123;</span><br><span class="line">        <span class="comment">// 一进页面先调用一次</span></span><br><span class="line">        <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 等页面渲染完成后调用</span></span><br><span class="line">        <span class="attr">flush</span>: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">        <span class="comment">// 深度监听</span></span><br><span class="line">        <span class="attr">deep</span>: <span class="literal">true</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h2><p>一开始就会做一次<br>会自己去判断要对什么内容进行监听，可以做到同时对多个数据的监听<br><strong>停止监听</strong><br>要手动停止一个侦听器，请调用 <code>watch</code> 或 <code>watchEffect</code> 返回的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unwatch = <span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...当该侦听器不再需要时</span></span><br><span class="line"><span class="title function_">unwatch</span>()</span><br></pre></td></tr></table></figure><p>注意，需要异步创建侦听器的情况很少，请尽可能选择同步创建。如果需要等待一些异步数据，你可以使用条件式的侦听逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要异步请求得到的数据</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (data.<span class="property">value</span>) &#123;</span><br><span class="line">    <span class="comment">// 数据加载后执行某些操作...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="watch-vs-watchEffect​"><a href="#watch-vs-watchEffect​" class="headerlink" title="watch vs. watchEffect​"></a><code>watch</code> vs. <code>watchEffect</code><a href="https://cn.vuejs.org/guide/essentials/watchers.html#watch-vs-watcheffect">​</a></h3><p><code>watch</code> 和 <code>watchEffect</code> 都能响应式地执行有副作用的回调。它们之间的主要区别是追踪响应式依赖的方式：</p><ul><li><code>watch</code> 只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。<code>watch</code> 会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。</li><li><code>watchEffect</code>，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确。</li></ul><h2 id="模板引用"><a href="#模板引用" class="headerlink" title="模板引用"></a>模板引用</h2><p>ref方法不仅可以定义响应式数据，还可以用于获取dom节点，和获取子组件实例<br>ref仅仅用于做地址的指向</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div ref=&quot;box&quot;&gt;123&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">      const box = ref(null);</span><br><span class="line">      onMounted(()=&gt;&#123;</span><br><span class="line">        console.log(box.value);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="props和emit"><a href="#props和emit" class="headerlink" title="props和emit"></a>props和emit</h2><p>在父组件中注册子组件时，（components和props）写在和setup并列的层级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Child count = &quot;5&quot; @fn = &quot;fn&quot;/&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Child from &#x27;./Child.vue&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">      Child</span><br><span class="line">    &#125;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">      const count = ref(1); </span><br><span class="line">      const fn = () =&gt; &#123;</span><br><span class="line">        console.log(&quot;fn&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;child子组件 - &#123;&#123; count &#125;&#125; - &lt;button @click=&quot;handleClick&quot;&gt;btn&lt;/button&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    // 接收父组件的值</span><br><span class="line">    props:[&quot;count&quot;],</span><br><span class="line">    setup(props,context)&#123;</span><br><span class="line">      // setup中的第一个参数props的作用：可以用props的值作为组件的data的初始值或者在其他在setup里面要用props的时候都需要用到第一参数</span><br><span class="line">      const handleClick = () =&gt; &#123;</span><br><span class="line">        context.emit(&quot;fn&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">      return &#123;</span><br><span class="line">        handleClick</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>父组件的数据，不管中间有多少层，直接传递给子孙组件<br>依赖注入解释是：给父组件加一个依赖（provide），给子组件加一个注入（inject）</p><h3 id="一-Provide（提供）"><a href="#一-Provide（提供）" class="headerlink" title="(一) Provide（提供）"></a>(一) Provide（提供）</h3><p>要为组件后代提供数据，需要使用到provide</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从vue中结构provide</span></span><br><span class="line"><span class="keyword">import</span> &#123; provide &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">provide</span>(<span class="string">&#x27;count&#x27;</span>,<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123; provide &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们需要提供依赖当前组件实例的状态，那么可以：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; provide, reactive, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 使用函数的形式，可以访问到 `this`</span></span><br><span class="line">    <span class="title function_">provide</span>(<span class="string">&#x27;count&#x27;</span>,count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二-应用层-Provide"><a href="#二-应用层-Provide" class="headerlink" title="(二) 应用层 Provide"></a>(二) 应用层 Provide</h3><p>除了在一个组件中提供依赖，我们还可以在整个应用层面提供依赖：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;&#125;)</span><br><span class="line">app.<span class="title function_">provide</span>(<span class="comment">/* 注入名 */</span> <span class="string">&#x27;message&#x27;</span>, <span class="comment">/* 值 */</span> <span class="string">&#x27;hello!&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在应用级别提供的数据在该应用内的所有组件中都可以注入。这在你编写<strong>插件</strong>时会特别有用，因为插件一般都不会使用组件形式来提供值。</p><h3 id="三-Inject（注入）"><a href="#三-Inject（注入）" class="headerlink" title="(三) Inject（注入）"></a>(三) Inject（注入）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 注入别名 newCount ; 默认值：20（第二个参数）</span></span><br><span class="line">        <span class="keyword">const</span> newCount = <span class="title function_">inject</span>(<span class="string">&#x27;count&#x27;</span>, <span class="number">20</span>)</span><br><span class="line">        <span class="keyword">const</span> msg = <span class="title function_">inject</span>(<span class="string">&#x27;msg&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            newCount,</span><br><span class="line">            msg</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不能放入setup中的选项"><a href="#不能放入setup中的选项" class="headerlink" title="不能放入setup中的选项"></a>不能放入setup中的选项</h2><ul><li>props</li><li>components</li><li>自定义指令</li></ul><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><h3 id="在-setup-中访问路由和当前路由"><a href="#在-setup-中访问路由和当前路由" class="headerlink" title="在 setup 中访问路由和当前路由"></a>在 <code>setup</code> 中访问路由和当前路由</h3><p>因为我们在 <code>setup</code> 里面没有访问 <code>this</code>，所以我们不能再直接访问 <code>this.$router</code> 或 <code>this.$route</code>。作为替代，我们使用 <code>useRouter</code> 和 <code>useRoute</code> 函数：<br><strong>只能在setup的顶层进行调用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRouter, useRoute &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 创建useRouter和useRoute调用变量</span></span><br><span class="line">    <span class="keyword">const</span> router = <span class="title function_">useRouter</span>()</span><br><span class="line">    <span class="keyword">const</span> route = <span class="title function_">useRoute</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">pushWithQuery</span>(<span class="params">query</span>) &#123;</span><br><span class="line">      router.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;search&#x27;</span>,</span><br><span class="line">        <span class="attr">query</span>: &#123;</span><br><span class="line">          ...route.<span class="property">query</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>route</code> 对象是一个响应式对象，所以它的任何属性都可以被监听，但你应该<strong>避免监听整个 <code>route</code></strong> 对象。在大多数情况下，你应该直接监听你期望改变的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRoute &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> route = <span class="title function_">useRoute</span>()</span><br><span class="line">    <span class="keyword">const</span> userData = <span class="title function_">ref</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当参数更改时获取用户信息</span></span><br><span class="line">    <span class="title function_">watch</span>(</span><br><span class="line">      <span class="function">() =&gt;</span> route.<span class="property">params</span>.<span class="property">id</span>,</span><br><span class="line">      <span class="keyword">async</span> newId =&gt; &#123;</span><br><span class="line">        userData.<span class="property">value</span> = <span class="keyword">await</span> <span class="title function_">fetchUser</span>(newId)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，在模板中我们仍然可以访问 <code>$router</code> 和 <code>$route</code>，所以不需要在 <code>setup</code> 中返回 <code>router</code> 或 <code>route</code>。</p><h3 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h3><p>虽然你仍然可以通过 <code>setup</code> 函数来使用组件内的导航守卫，但 Vue Router 将更新和离开守卫作为 组合式 API 函数公开：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onBeforeRouteLeave, onBeforeRouteUpdate &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 与 beforeRouteLeave 相同，无法访问 `this`</span></span><br><span class="line">    <span class="title function_">onBeforeRouteLeave</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> answer = <span class="variable language_">window</span>.<span class="title function_">confirm</span>(</span><br><span class="line">        <span class="string">&#x27;Do you really want to leave? you have unsaved changes!&#x27;</span></span><br><span class="line">      )</span><br><span class="line">      <span class="comment">// 取消导航并停留在同一页面上</span></span><br><span class="line">      <span class="keyword">if</span> (!answer) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> userData = <span class="title function_">ref</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与 beforeRouteUpdate 相同，无法访问 `this`</span></span><br><span class="line">    <span class="title function_">onBeforeRouteUpdate</span>(<span class="keyword">async</span> (to, <span class="keyword">from</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">//仅当 id 更改时才获取用户，例如仅 query 或 hash 值已更改</span></span><br><span class="line">      <span class="keyword">if</span> (to.<span class="property">params</span>.<span class="property">id</span> !== <span class="keyword">from</span>.<span class="property">params</span>.<span class="property">id</span>) &#123;</span><br><span class="line">        userData.<span class="property">value</span> = <span class="keyword">await</span> <span class="title function_">fetchUser</span>(to.<span class="property">params</span>.<span class="property">id</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组合式 API 守卫也可以用在任何由 <code>&lt;router-view&gt;</code> 渲染的组件中，它们不必像组件内守卫那样直接用在路由组件上。</p><h3 id="项目中动态路由的使用"><a href="#项目中动态路由的使用" class="headerlink" title="项目中动态路由的使用"></a>项目中动态路由的使用</h3><p>在路由表中使用 <code>/:id</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/detail/:id&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../pages/detail/Index.vue&#x27;</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>在编程式路由跳转是传递id值:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">van-card</span></span></span><br><span class="line"><span class="tag">          <span class="attr">v-for</span>=<span class="string">&quot;item in recommendList&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:key</span>=<span class="string">&quot;item&quot;</span></span></span><br><span class="line"><span class="tag">          @<span class="attr">click</span>=<span class="string">&quot;goDetail(item.productId)&quot;</span></span></span><br><span class="line"><span class="tag">          &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">van-card</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">goDetail</span> = (<span class="params">id: string</span>) =&gt; &#123;</span><br><span class="line">  router.<span class="title function_">push</span>(<span class="string">&#x27;/detail/&#x27;</span> + id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在跳转的组件请求数据时，解构引入userRoute，并通过 <code>route.params.id</code> ：获取当前路由信息中的id，并通过参数 id 请求想要的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRoute &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;http://www.pudge.wang:4000/detail&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">productId</span>: route.<span class="property">params</span>.<span class="property">id</span> &#125;),</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(res)</span></span><br><span class="line">      <span class="keyword">if</span> (res.<span class="property">status</span> === <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">        <span class="title class_">DetailList</span>.<span class="property">value</span> = res.<span class="property">result</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>可以通过调用 <code>useStore</code> 函数，来在 <code>setup</code> 钩子函数中访问 store。这与在组件中使用选项式 API 访问 <code>this.$store</code> 是等效的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup () &#123;</span><br><span class="line">    <span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问-State-和-Getter"><a href="#访问-State-和-Getter" class="headerlink" title="访问 State 和 Getter"></a>访问 State 和 Getter</h3><p>为了访问 state 和 getter，需要创建 <code>computed</code> 引用以保留响应性，这与在选项式 API 中创建计算属性等效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup () &#123;</span><br><span class="line">    <span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 在 computed 函数中访问 state</span></span><br><span class="line">      <span class="attr">count</span>: <span class="title function_">computed</span>(<span class="function">() =&gt;</span> store.<span class="property">state</span>.<span class="property">count</span>),</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在 computed 函数中访问 getter</span></span><br><span class="line">      <span class="attr">double</span>: <span class="title function_">computed</span>(<span class="function">() =&gt;</span> store.<span class="property">getters</span>.<span class="property">double</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问-Mutation-和-Action"><a href="#访问-Mutation-和-Action" class="headerlink" title="访问 Mutation 和 Action"></a>访问 Mutation 和 Action</h3><p>要使用 mutation 和 action 时，只需要在 <code>setup</code> 钩子函数中调用 <code>commit</code> 和 <code>dispatch</code> 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup () &#123;</span><br><span class="line">    <span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 使用 mutation</span></span><br><span class="line">      <span class="attr">increment</span>: <span class="function">() =&gt;</span> store.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>),</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 使用 action</span></span><br><span class="line">      <span class="attr">asyncIncrement</span>: <span class="function">() =&gt;</span> store.<span class="title function_">dispatch</span>(<span class="string">&#x27;asyncIncrement&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="setup属性"><a href="#setup属性" class="headerlink" title="setup属性"></a>setup属性</h2><ul><li>使用前必须安装volar插件</li><li>在script上添加setup属性可以省去</li><li>export default{}</li><li>setup函数</li><li>return{}</li><li>对于组件来说，只需要引入不需要注册</li><li>在组件<strong>父传子</strong>时，props的写法：const props &#x3D; defineProps([‘自定义属性名’])或对象形式<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>(&#123;</span><br><span class="line">    <span class="attr">num</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="number">999</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><strong>组件子传父</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> emit = <span class="title function_">defineEmits</span>([<span class="string">&quot;fn&quot;</span>])</span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">emit</span>(<span class="string">&quot;fn&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">Vue3 组合式API</summary>
    
    
    
    <category term="前端" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
    <category term="Vue" scheme="https://fanxing28.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue2 和 Vue3的比较</title>
    <link href="https://fanxing28.github.io/2023/12/13/%E5%89%8D%E7%AB%AF/Vue/Vue2%20%E5%92%8C%20Vue3%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <id>https://fanxing28.github.io/2023/12/13/%E5%89%8D%E7%AB%AF/Vue/Vue2%20%E5%92%8C%20Vue3%E7%9A%84%E6%AF%94%E8%BE%83/</id>
    <published>2023-12-13T14:50:00.000Z</published>
    <updated>2023-12-14T14:56:23.664Z</updated>
    
    <content type="html"><![CDATA[<ol><li>vue3 的源码用 ts 重写了，对 ts 有了更好的支持.</li><li>它们的响应式的原理不一样<ul><li>Vue2 响应式原理：Object.definedProperty</li><li>Vue3 响应式原理：proxy（更加高效地跟踪数据变化，减少了一些不必要的计算和操作。）</li><li>Proxy在性能上有一定的优势，因为它可以直接代理整个对象，而不需要像Object.defineProperty一样遍历所有的属性进行代理。</li></ul></li><li>vue3 的每一个组件不再需要唯一的根元素</li><li>v-if 和 v-for 的优先级<ul><li>Vue2 中v-for的优先级更高</li><li>Vue3 中v-if的优先级更高</li></ul></li><li>vue3 的依赖注入可以有响应式的</li><li>Vue3中引入了Composition API，这是一组用于组合组件逻辑的函数，可以让开发者更加方便地组织组件逻辑代码，并且可以提高代码的复用性。</li><li>diff 算法做了更新</li><li>vue3 中<strong>新增</strong>了<ul><li>Teleport 传送门，可以让开发者更加方便地控制组件的挂载位置</li><li>Suspense组件，可以让开发者更加方便地处理异步组件</li><li>vue3 的侦听器添加了 this.$watch 方法，可以开启和关闭监听</li><li>提供了一些新的API，比如ref()、reactive()、computed()等，用于更方便地管理响应式数据。</li><li>errorCaptured、renderTracked、renderTriggered三个，可以更方便地进行组件的状态管理和调试。</li></ul></li><li>vue3 中<strong>删除</strong>了<ul><li>按键码修饰符</li><li>中央事件总线</li><li>过滤器，可以使用计算属性或者自定义指令做文本格式化</li><li>删除了混入功能，可以使用组合式 api 做功能分发</li></ul></li><li>Vue3 中<strong>修改</strong>了<ul><li>生命周期卸载阶段的名字由destroy改为了unmount</li><li>Vue3中重新实现了VNode的算法，通过缩小VNode的类型和标记，可以更好地提高渲染性能和减小VNode对象的内存占用。</li></ul></li></ol><h2 id="ref与reactive区别"><a href="#ref与reactive区别" class="headerlink" title="ref与reactive区别"></a>ref与reactive区别</h2><ul><li>ref定义的是基本数据类型</li><li>ref通过Object.defineProperty()的get和set实现数据劫持</li><li>ref操作数据 <code>.value</code>，读取时不需要 <code>.value</code></li><li>reactive定义对象或数组数据类型</li><li>reactive通过Proxy实现数据劫持</li><li>reactive操作和读取数据不需要 <code>.value</code></li></ul><h2 id="vue2和vue3的响应式原理"><a href="#vue2和vue3的响应式原理" class="headerlink" title="vue2和vue3的响应式原理"></a>vue2和vue3的响应式原理</h2><p>vue2的响应式原理用<strong>Object.defineProperty的get和set进行数据劫持</strong>，从而实现响应式 vue2中只有get和set方法去进行属性的读取和修改操作，当我们进行新增，删除时，页面不会实时更新 直接通过下标改数组，页面也不会实时更新<br>vue3中响应式原理使用Proxy进行代理，使用window内置对象Reflect反射，学了Es6的语法的就知道我们在使用Proxy进行代理，好比甲方公司给出需要什么技术的前端攻城狮，让乙方去干招聘、面试等环节 Proxy可以拦截对象中任意的属性变化，当然包括读写，添加，删除等 Reflect对源对象属性进行操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p=<span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line"><span class="comment">// 读取属性时调用</span></span><br><span class="line">    get (target, propName) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, propName)</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="comment">//修改属性或添加属性时调用</span></span><br><span class="line">    set (target, propName, value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, propName, value)</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="comment">//删除属性时调用</span></span><br><span class="line">    deleteProperty (target, propName) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, propName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Vue2 和 Vue3的比较</summary>
    
    
    
    <category term="前端" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
    <category term="Vue" scheme="https://fanxing28.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 教程</title>
    <link href="https://fanxing28.github.io/2023/12/13/%E5%85%B6%E4%BB%96/MarkDown/Markdown%20%E6%95%99%E7%A8%8B/"/>
    <id>https://fanxing28.github.io/2023/12/13/%E5%85%B6%E4%BB%96/MarkDown/Markdown%20%E6%95%99%E7%A8%8B/</id>
    <published>2023-12-13T14:33:00.000Z</published>
    <updated>2023-12-14T14:56:23.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown教程"><a href="#Markdown教程" class="headerlink" title="&amp;Markdown教程"></a>&amp;Markdown教程</h1><h2 id="一-Markdown语言的基础认知"><a href="#一-Markdown语言的基础认知" class="headerlink" title="一.Markdown语言的基础认知"></a>一.Markdown语言的基础认知</h2><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。<br>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。<br>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。<br>Markdown 编写的文档后缀为 <strong>.md</strong>, <strong>.markdown</strong>。<br>使用 <strong>Typora 编辑器</strong>来讲解 Markdown 的语法，Typora 支持 MacOS 、Windows、Linux 平台，且包含多种主题，编辑后直接渲染出效果。<br><strong>Typora 编辑器</strong>：支持导出HTML、PDF、Word、图片等多种类型文件。<br><a href="https://typora.io/">Typora 官网</a><br><a href="https://c.runoob.com/front-end/712">在线编辑器</a></p><h2 id="二-Markdown标题"><a href="#二-Markdown标题" class="headerlink" title="二.Markdown标题"></a>二.Markdown标题</h2><h3 id="1-使用-和-标记一级和二级标题"><a href="#1-使用-和-标记一级和二级标题" class="headerlink" title="1.使用 &#x3D; 和 - 标记一级和二级标题"></a>1.使用 &#x3D; 和 - 标记一级和二级标题</h3><p>&#x3D; 和 - 标记语法格式如下：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 我展示的是一级标题</span><br><span class="line">## 我展示的是二级标题</span><br></pre></td></tr></table></figure><p>显示效果如下所示：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/01986C87-7E19-4497-878E-AE996AFC088E.jpg" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/01986C87-7E19-4497-878E-AE996AFC088E.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/01986C87-7E19-4497-878E-AE996AFC088E.jpg"></p><h3 id="2-使用-号标记"><a href="#2-使用-号标记" class="headerlink" title="2.使用 # 号标记"></a>2.使用 # 号标记</h3><p>使用 <strong>#</strong> 号可表示 1-6 级标题，一级标题对应一个 <strong>#</strong> 号，二级标题对应两个 <strong>#</strong> 号，以此类推。</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><p>显示效果如下所示：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/md2.gif" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/md2.gif" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/md2.gif"></p><h2 id="三-Markdown-段落"><a href="#三-Markdown-段落" class="headerlink" title="三.Markdown 段落"></a>三.Markdown 段落</h2><p>Markdown 段落没有特殊的格式，直接编写文字就好，<strong>段落的换行是使用两个以上空格加上回车</strong>。<br>显示效果如下所示：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/36A89BDA-A062-4D66-A41B-0EBEE7891AB9.jpg" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/36A89BDA-A062-4D66-A41B-0EBEE7891AB9.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/36A89BDA-A062-4D66-A41B-0EBEE7891AB9.jpg"><br>当然也可以在段落后面使用一个空行来表示重新开始一个段落。<br>显示效果如下所示：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/3F254936-778E-417A-BEF2-467116A55D00.jpg" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/3F254936-778E-417A-BEF2-467116A55D00.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/3F254936-778E-417A-BEF2-467116A55D00.jpg"></p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>Markdown 可以使用以下几种字体：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_斜体文本_ </span><br><span class="line">**粗体文本** </span><br><span class="line">**_粗斜体文本_**</span><br></pre></td></tr></table></figure><p>显示效果如下所示：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/md3.gif" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/md3.gif" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/md3.gif"></p><h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">---</span><br><span class="line">---</span><br><span class="line">---</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>显示效果如下所示：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/3F46EAA9-DADE-48FD-99AA-DF7BEBFAA4FA.jpg" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/3F46EAA9-DADE-48FD-99AA-DF7BEBFAA4FA.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/3F46EAA9-DADE-48FD-99AA-DF7BEBFAA4FA.jpg"></p><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线  <strong><code>~~</code></strong>  即可，实例如下：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUNOOB.COM </span><br><span class="line">GOOGLE.COM </span><br><span class="line">~~BAIDU.COM~~</span><br></pre></td></tr></table></figure><p>显示效果如下所示：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/B5270A31-15D0-410B-AE1D-B9655B8F331C.jpg" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/B5270A31-15D0-410B-AE1D-B9655B8F331C.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/B5270A31-15D0-410B-AE1D-B9655B8F331C.jpg"></p><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p>下划线可以通过 HTML 的 <code>&lt;u&gt;</code> 标签来实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">带下划线文本</span><br></pre></td></tr></table></figure><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>脚注是对文本的补充说明。<br>Markdown 脚注的格式如下:</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^要注明的文本]</span><br></pre></td></tr></table></figure><p>以下实例演示了脚注的用法：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">创建脚注格式类似这样 [^RUNOOB]。</span><br><span class="line">[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！</span><br></pre></td></tr></table></figure><p>显示效果如下所示：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/md5.gif" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/md5.gif" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/md5.gif"></p><h2 id="四-Markdown-列表"><a href="#四-Markdown-列表" class="headerlink" title="四.Markdown 列表"></a>四.Markdown 列表</h2><p>Markdown 支持有序列表和无序列表。<br>无序列表使用星号(<em><strong>)、加号(+</strong>)或是减号(</em>*-**)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 第一项 </span><br><span class="line">- 第二项 </span><br><span class="line">- 第三项 </span><br><span class="line">- 第一项 </span><br><span class="line">- 第二项  </span><br><span class="line">- 第三项 </span><br><span class="line">- 第一项</span><br><span class="line">- 第二项</span><br><span class="line">- 第三项  </span><br></pre></td></tr></table></figure><p>显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/89446A8E-6D83-4666-AACC-980145D5F070.jpg" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/89446A8E-6D83-4666-AACC-980145D5F070.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/89446A8E-6D83-4666-AACC-980145D5F070.jpg"><br>有序列表使用数字并加上 <strong>.</strong> 号来表示，如：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 第一项</span><br><span class="line">2. 第二项</span><br><span class="line">3. 第三项</span><br></pre></td></tr></table></figure><p>显示结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/560384BB-2B00-41D5-ACF2-18972F7F2775.jpg" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/560384BB-2B00-41D5-ACF2-18972F7F2775.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/560384BB-2B00-41D5-ACF2-18972F7F2775.jpg"></p><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><p>列表嵌套只需在子列表中的选项前面添加四个空格即可：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 第一项：</span><br><span class="line">    - 第一项嵌套的第一个元素</span><br><span class="line">    - 第一项嵌套的第二个元素</span><br><span class="line">2. 第二项：</span><br><span class="line">    - 第二项嵌套的第一个元素</span><br><span class="line">    - 第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure><p>显示结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/8ED795DA-F124-4E70-BA71-57CD9CF958A4.jpg" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/8ED795DA-F124-4E70-BA71-57CD9CF958A4.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/8ED795DA-F124-4E70-BA71-57CD9CF958A4.jpg"></p><h2 id="五-Markdown-区块"><a href="#五-Markdown-区块" class="headerlink" title="五.Markdown 区块"></a>五.Markdown 区块</h2><p>Markdown 区块引用是在段落开头使用 <strong>&gt;</strong> 符号 ，然后后面紧跟一个<strong>空格</strong>符号：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 区块引用 菜鸟教程 学的不仅是技术更是梦想</span><br></pre></td></tr></table></figure><p>显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/DFE1124E-BC38-4C12-B7AC-053E560D4C9C.jpg" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/DFE1124E-BC38-4C12-B7AC-053E560D4C9C.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/DFE1124E-BC38-4C12-B7AC-053E560D4C9C.jpg"><br>另外区块是可以嵌套的，一个 <strong>&gt;</strong> 符号是最外层，两个 <strong>&gt;</strong> 符号是第一层嵌套，以此类推：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; 最外层</span><br><span class="line">&gt; </span><br><span class="line">&gt; &gt; 第一层嵌套</span><br><span class="line">&gt; &gt; </span><br><span class="line">&gt; &gt; &gt; 第二层嵌套</span><br></pre></td></tr></table></figure><p>显示结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/AA0A4A6A-33A7-48C7-971F-73FFC8FE85B0.jpg" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/AA0A4A6A-33A7-48C7-971F-73FFC8FE85B0.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/AA0A4A6A-33A7-48C7-971F-73FFC8FE85B0.jpg"></p><h3 id="区块中使用列表"><a href="#区块中使用列表" class="headerlink" title="区块中使用列表"></a>区块中使用列表</h3><p>区块中使用列表实例如下：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; 区块中使用列表</span><br><span class="line">&gt; </span><br><span class="line">&gt; 1. 第一项</span><br><span class="line">&gt; 2. 第二项</span><br><span class="line">&gt; </span><br><span class="line">&gt; - 第一项</span><br><span class="line">&gt; - 第二项</span><br><span class="line">&gt; - 第三项</span><br></pre></td></tr></table></figure><p>显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/E3BF6399-6483-4C7A-8502-AE75E8D66C96.jpg" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/E3BF6399-6483-4C7A-8502-AE75E8D66C96.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/E3BF6399-6483-4C7A-8502-AE75E8D66C96.jpg"></p><h3 id="列表中使用区块"><a href="#列表中使用区块" class="headerlink" title="列表中使用区块"></a>列表中使用区块</h3><p>如果要在列表项目内放进区块，那么就需要在 <strong>&gt;</strong> 前添加四个空格的缩进。<br>区块中使用列表实例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Plain Text</span><br><span class="line"></span><br><span class="line">- 第一项 &gt; 菜鸟教程 &gt; 学的不仅是技术更是梦想</span><br><span class="line">- 第二项</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显示结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/1B894FB4-53AC-4E2D-BA30-F4AE4DFA8B97.jpg" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/1B894FB4-53AC-4E2D-BA30-F4AE4DFA8B97.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/1B894FB4-53AC-4E2D-BA30-F4AE4DFA8B97.jpg"></p><h2 id="六-Markdown-代码"><a href="#六-Markdown-代码" class="headerlink" title="六.Markdown 代码"></a>六.Markdown 代码</h2><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来，例如：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`printf()` 函数</span><br></pre></td></tr></table></figure><p>显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/C928FDA3-E0A7-4AFF-AB2A-B3AF44F93DF9.jpg" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/C928FDA3-E0A7-4AFF-AB2A-B3AF44F93DF9.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/C928FDA3-E0A7-4AFF-AB2A-B3AF44F93DF9.jpg"></p><h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>代码区块使用 <strong>4 个空格</strong>或者一个<strong>制表符（Tab 键）</strong>。<br>实例如下:<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/55EDFE05-5F27-458E-AFE0-7B96685C9603.jpg" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/55EDFE05-5F27-458E-AFE0-7B96685C9603.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/55EDFE05-5F27-458E-AFE0-7B96685C9603.jpg"><br>显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/6DC89E5C-B41A-4938-97D8-D7D06B879F91.jpg" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/6DC89E5C-B41A-4938-97D8-D7D06B879F91.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/6DC89E5C-B41A-4938-97D8-D7D06B879F91.jpg"><br>你也可以用 <strong>&#96;&#96;&#96;</strong> 包裹一段代码，并指定一种语言（也可以不指定）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Plain Text ​`javascript $(document).ready(function () &#123; alert(&#x27;RUNOOB&#x27;); &#125;); ​`</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/88F52386-2F98-4D7E-8935-E43BECA6D868.jpg" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/88F52386-2F98-4D7E-8935-E43BECA6D868.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/88F52386-2F98-4D7E-8935-E43BECA6D868.jpg"></p><h2 id="七-Markdown-链接"><a href="#七-Markdown-链接" class="headerlink" title="七.Markdown 链接"></a>七.Markdown 链接</h2><p>链接使用方法如下：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[链接名称](链接地址)</span><br><span class="line">或者</span><br><span class="line">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一个链接 [菜鸟教程](https://www.runoob.com)</span><br></pre></td></tr></table></figure><p>显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/49E6CB42-F780-4DA6-8290-DC757B51FB9A.jpg" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/49E6CB42-F780-4DA6-8290-DC757B51FB9A.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/49E6CB42-F780-4DA6-8290-DC757B51FB9A.jpg"><br>直接使用链接地址：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[https://www.runoob.com](https://www.runoob.com)</span><br></pre></td></tr></table></figure><p>显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/9BFF60A1-DD71-4B63-987B-4665B31C7787.jpg" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/9BFF60A1-DD71-4B63-987B-4665B31C7787.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/9BFF60A1-DD71-4B63-987B-4665B31C7787.jpg"></p><h3 id="高级链接"><a href="#高级链接" class="headerlink" title="高级链接"></a>高级链接</h3><p>我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个链接用 1 作为网址变量 [Google](http://static.runoob.com/images/runoob-logo.png) 这个链接用 runoob 作为网址变量 [Runoob](http://www.runoob.com/) 然后在文档的结尾为变量赋值（网址）</span><br></pre></td></tr></table></figure><p>显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/EC3ED5D2-4F0D-492A-81B3-D485623D1A9E.jpg" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/EC3ED5D2-4F0D-492A-81B3-D485623D1A9E.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/EC3ED5D2-4F0D-492A-81B3-D485623D1A9E.jpg"></p><h2 id="八-Markdown-图片"><a href="#八-Markdown-图片" class="headerlink" title="八.Markdown 图片"></a>八.Markdown 图片</h2><p>Markdown 图片语法格式如下：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![alt 属性文本](图片地址)</span><br><span class="line">![alt 属性文本](图片地址 &quot;可选标题&quot;)</span><br></pre></td></tr></table></figure><ul><li>开头一个感叹号 !</li><li>接着一个方括号，里面放上图片的替代文字</li><li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。<br>使用实例：<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png)</span><br><span class="line">![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png &quot;RUNOOB&quot;)</span><br></pre></td></tr></table></figure>显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/A042DF30-C232-46F3-8436-7D6C35351BBD.jpg" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/A042DF30-C232-46F3-8436-7D6C35351BBD.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/A042DF30-C232-46F3-8436-7D6C35351BBD.jpg"></li></ul><p>当然，你也可以像网址那样对图片网址使用变量:</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个链接用 1 作为网址变量 [RUNOOB](http://static.runoob.com/images/runoob-logo.png). 然后在文档的结尾为变量赋值（网址）</span><br></pre></td></tr></table></figure><p>显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/75AA6EBF-CC57-44A6-A585-5EE3DD94E42A.jpg" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/75AA6EBF-CC57-44A6-A585-5EE3DD94E42A.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/75AA6EBF-CC57-44A6-A585-5EE3DD94E42A.jpg"><br>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的<br> 标签。</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](http://static.runoob.com/images/runoob-logo.png)</span><br></pre></td></tr></table></figure><p>显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/55F2A67D-F4BD-4960-AC55-DC690A415878.jpg" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/55F2A67D-F4BD-4960-AC55-DC690A415878.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/55F2A67D-F4BD-4960-AC55-DC690A415878.jpg"></p><h2 id="九-Markdown-表格"><a href="#九-Markdown-表格" class="headerlink" title="九.Markdown 表格"></a>九.Markdown 表格</h2><p>Markdown 制作表格使用 <strong>|</strong> 来分隔不同的单元格，使用 <strong>-</strong> 来分隔表头和其他行。<br>语法格式如下：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 表头 | 表头 | </span><br><span class="line">| ---- | ---- | </span><br><span class="line">| 单元格 | 单元格 | </span><br><span class="line">| 单元格 | 单元格 |</span><br></pre></td></tr></table></figure><p>以上代码显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/23EACC50-38E0-4284-B99A-6BC22E284BAC.jpg" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/23EACC50-38E0-4284-B99A-6BC22E284BAC.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/23EACC50-38E0-4284-B99A-6BC22E284BAC.jpg"><br>对齐方式<br><strong>我们可以设置表格的对齐方式：</strong></p><ul><li><strong>-:</strong> 设置内容和标题栏居右对齐。</li><li><strong>:-</strong> 设置内容和标题栏居左对齐。</li><li><strong>:-:</strong> 设置内容和标题栏居中对齐。<br>实例如下：<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 | </span><br><span class="line">| :-----| ----: | :----: | </span><br><span class="line">| 单元格 | 单元格 | 单元格 | </span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure>以上代码显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/87DE9D5C-44FB-4693-8735-194D3779EC3E.jpg" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/87DE9D5C-44FB-4693-8735-194D3779EC3E.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/87DE9D5C-44FB-4693-8735-194D3779EC3E.jpg"></li></ul><h2 id="十-Markdown-高级技巧"><a href="#十-Markdown-高级技巧" class="headerlink" title="十.Markdown 高级技巧"></a>十.Markdown 高级技巧</h2><h3 id="支持的-HTML-元素"><a href="#支持的-HTML-元素" class="headerlink" title="支持的 HTML 元素"></a>支持的 HTML 元素</h3><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。<br>目前支持的 HTML 元素有：<code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>等 ，如：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 Ctrl+Alt+Del 重启电脑</span><br></pre></td></tr></table></figure><p>输出结果为：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/81999271-F914-428D-B7BF-164BDC67CAAC.jpg" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/81999271-F914-428D-B7BF-164BDC67CAAC.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/81999271-F914-428D-B7BF-164BDC67CAAC.jpg"></p><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**文本加粗** ** 正常显示星号 **</span><br></pre></td></tr></table></figure><p>输出结果为：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/CA0E0162-0C48-41CD-B57A-CB32A4287C02.jpg" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/CA0E0162-0C48-41CD-B57A-CB32A4287C02.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/CA0E0162-0C48-41CD-B57A-CB32A4287C02.jpg"><br>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\ 反斜线 ` 反引号</span><br><span class="line">- 星号 _ 下划线 &#123;&#125; 花括号 [] 方括号 () 小括号</span><br><span class="line"># 井字号</span><br><span class="line">- 加号</span><br><span class="line">- 减号 . 英文句点 ! 感叹号</span><br></pre></td></tr></table></figure><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 <code>$$</code> 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$ </span><br><span class="line">\mathbf&#123;V&#125;_1 \times \mathbf&#123;V&#125;_2 = \begin&#123;vmatrix&#125; </span><br><span class="line">\mathbf&#123;i&#125; &amp; \mathbf&#123;j&#125; &amp; \mathbf&#123;k&#125; \ </span><br><span class="line">\frac&#123;\partial X&#125;&#123;\partial u&#125; &amp; \frac&#123;\partial Y&#125;&#123;\partial u&#125; &amp; 0 \ \frac&#123;\partial X&#125;&#123;\partial v&#125; &amp; \frac&#123;\partial Y&#125;&#123;\partial v&#125; &amp; 0 \ </span><br><span class="line">\end&#123;vmatrix&#125; </span><br><span class="line">$&#123;$tep1&#125;&#123;\style&#123;visibility:hidden&#125;&#123;(x+1)(x+1)&#125;&#125; </span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>输出结果为：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/1061D800-D44C-436D-A1EA-1CBDA95A5209.jpg" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/1061D800-D44C-436D-A1EA-1CBDA95A5209.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/1061D800-D44C-436D-A1EA-1CBDA95A5209.jpg"></p><h3 id="typora-画流程图、时序图-顺序图-、甘特图"><a href="#typora-画流程图、时序图-顺序图-、甘特图" class="headerlink" title="typora 画流程图、时序图(顺序图)、甘特图"></a>typora 画流程图、时序图(顺序图)、甘特图</h3><p>复制以下代码使用 typora 的源码模式粘贴到编辑器中查看效果：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/22A9BC11-BA3E-40D8-90B0-DC4FD29F9C02.jpg" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/22A9BC11-BA3E-40D8-90B0-DC4FD29F9C02.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/22A9BC11-BA3E-40D8-90B0-DC4FD29F9C02.jpg"><br>以下几个实例效果图如下：<br><strong>1、横向流程图源码格式：</strong></p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">​`mermaid graph LR A[方形] --&gt;B(圆角) B --&gt; C&#123;条件a&#125; C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图] ​`</span><br></pre></td></tr></table></figure><p><strong>2、竖向流程图源码格式：</strong></p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">​`mermaid graph TD A[方形] --&gt; B(圆角) B --&gt; C&#123;条件a&#125; C --&gt; |a=1| D[结果1] C --&gt; |a=2| E[结果2] F[竖向流程图] ​`</span><br></pre></td></tr></table></figure><p><strong>3、标准流程图源码格式：</strong></p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">​`flow st=&gt;start: 开始框 op=&gt;operation: 处理框 cond=&gt;condition: 判断框(是或否?) sub1=&gt;subroutine: 子流程 io=&gt;inputoutput: 输入输出框 e=&gt;end: 结束框 st-&gt;op-&gt;cond cond(yes)-&gt;io-&gt;e cond(no)-&gt;sub1(right)-&gt;op ​`</span><br></pre></td></tr></table></figure><p><strong>4、标准流程图源码格式（横向）：</strong></p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">​`flow st=&gt;start: 开始框 op=&gt;operation: 处理框 cond=&gt;condition: 判断框(是或否?) sub1=&gt;subroutine: 子流程 io=&gt;inputoutput: 输入输出框 e=&gt;end: 结束框 st(right)-&gt;op(right)-&gt;cond cond(yes)-&gt;io(bottom)-&gt;e cond(no)-&gt;sub1(right)-&gt;op ​`</span><br></pre></td></tr></table></figure><p><strong>5、UML时序图源码样例：</strong></p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">​`sequence 对象A-&gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--&gt;对象A: 我很好(响应) 对象A-&gt;对象B: 你真的好吗？ ​`</span><br></pre></td></tr></table></figure><p><strong>6、UML时序图源码复杂样例：</strong></p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">​`sequence Title: 标题：复杂使用 对象A-&gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--&gt;对象A: 我很好(响应) 对象B-&gt;小三: 你好吗 小三--&gt;&gt;对象A: 对象B找我了 对象A-&gt;对象B: 你真的好吗？ Note over 小三,对象B: 我们是朋友 participant C Note right of C: 没人陪我玩 ​`</span><br></pre></td></tr></table></figure><p><strong>7、UML标准时序图样例：</strong></p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">​`mermaid %% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头 sequenceDiagram participant 张三 participant 李四 张三-&gt;王五: 王五你好吗？ loop 健康检查 王五-&gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 &lt;br/&gt;看医生... 李四--&gt;&gt;张三: 很好! 王五-&gt;李四: 你怎么样? 李四--&gt;王五: 很好! ​`</span><br></pre></td></tr></table></figure><p><strong>8、甘特图样例：</strong></p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">​`mermaid %% 语法示例 gantt dateFormat YYYY-MM-DD title 软件开发甘特图 section 设计 需求 :done, des1, 2014-01-06,2014-01-08 原型 :active, des2, 2014-01-09, 3d UI设计 : des3, after des2, 5d 未来任务 : des4, after des3, 5d section 开发 学习准备理解需求 :crit, done, 2014-01-06,24h 设计框架 :crit, done, after des2, 2d 开发 :crit, active, 3d 未来任务 :crit, 5d 耍 :2d section 测试 功能测试 :active, a1, after des3, 3d 压力测试 :after a1 , 20h 测试报告 : 48h ​` </span><br></pre></td></tr></table></figure><p>效果图如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/md-flow.png" class="lazyload placeholder" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/md-flow.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="https://www.runoob.com/wp-content/uploads/2019/03/md-flow.png"></p><h2 id="十一-具体Markdown教程"><a href="#十一-具体Markdown教程" class="headerlink" title="十一.具体Markdown教程"></a>十一.具体Markdown教程</h2><p>参考链接：<br><a href="https://www.runoob.com/markdown/md-link.html">Markdown链接|菜鸟教程</a></p>]]></content>
    
    
    <summary type="html">Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。Markdown 编写的文档后缀为 **.md**, **.markdown**。</summary>
    
    
    
    <category term="其他" scheme="https://fanxing28.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    <category term="MarkDown" scheme="https://fanxing28.github.io/categories/%E5%85%B6%E4%BB%96/MarkDown/"/>
    
    
    <category term="MarkDown" scheme="https://fanxing28.github.io/tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title>数据处理</title>
    <link href="https://fanxing28.github.io/2023/12/10/%E5%B7%A5%E5%85%B7/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <id>https://fanxing28.github.io/2023/12/10/%E5%B7%A5%E5%85%B7/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</id>
    <published>2023-12-10T14:39:00.000Z</published>
    <updated>2023-12-14T14:56:23.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h1 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h1>]]></content>
    
    
    <summary type="html">项目中常见数据处理场景</summary>
    
    
    
    <category term="工具" scheme="https://fanxing28.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="https://fanxing28.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Vue 原理概念</title>
    <link href="https://fanxing28.github.io/2023/12/03/%E5%89%8D%E7%AB%AF/Vue/Vue%20%E5%8E%9F%E7%90%86%E6%A6%82%E5%BF%B5/"/>
    <id>https://fanxing28.github.io/2023/12/03/%E5%89%8D%E7%AB%AF/Vue/Vue%20%E5%8E%9F%E7%90%86%E6%A6%82%E5%BF%B5/</id>
    <published>2023-12-03T14:53:00.000Z</published>
    <updated>2023-12-03T15:05:25.582Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-服务器渲染"><a href="#一-服务器渲染" class="headerlink" title="一. 服务器渲染"></a>一. 服务器渲染</h2><p><strong>服务器渲染</strong>：前端的代码和后端的代码全在后端的框架上进行完成的<br><strong>后端渲染和前后端分离</strong></p><ul><li>后端渲染特点：速度快和更好的SEO优化（搜索引擎优化）</li><li>前后端分离：降低了开发人员的要求（只需要会前端或后端就可以了）和降低了服务端压力（处理是在每位用户的电脑中）<br>Vue 的后端渲染框架：nuxt React 的后端渲染框架：next</li></ul><h2 id="二-MVC-和-MVVM"><a href="#二-MVC-和-MVVM" class="headerlink" title="二. MVC 和 MVVM"></a>二. MVC 和 MVVM</h2><p>MVC 和 MVVM 都是常见的<strong>软件架构思想</strong><br>MVC 由三部分组成：</p><ul><li>model：数据层</li><li>view：视图层</li><li>controller：控制层</li><li>视图（View）：用户界面。</li><li>控制器（Controller）：业务逻辑</li><li>模型（Model）：数据保存<br>MVC 的通信方式：<blockquote><p>view -&gt; controller -&gt; model -&gt; view</p></blockquote></li></ul><p><img src="https://fanxingnotes.oss-cn-beijing.aliyuncs.com/images/front/vue/VueMVC%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.png" class="lazyload placeholder" data-srcset="https://fanxingnotes.oss-cn-beijing.aliyuncs.com/images/front/vue/VueMVC%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="VueMVC通信方式.png"><br>MVVM 有三部分组成：</p><ul><li>model：数据层（指的是后端传递的数据）</li><li>view：视图层（指的是所看到的页面）</li><li>viewmodel：视图模型层（连接 view 和 model 的桥梁）<br>将模型(Model) 转化成视图(View)<blockquote><p>实现的方式是： 数据绑定</p></blockquote></li></ul><p>将视图(View)转化成模型(Model)</p><blockquote><p>DOM 事件监听</p></blockquote><p>MVVM 的通信方式：</p><blockquote><p>view &lt;-&gt; viewmodel -&gt;&lt;- model</p></blockquote><p><img src="https://fanxingnotes.oss-cn-beijing.aliyuncs.com/images/front/vue/VueMVVM%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.png" class="lazyload placeholder" data-srcset="https://fanxingnotes.oss-cn-beijing.aliyuncs.com/images/front/vue/VueMVVM%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="VueMVVM通信方式.png"><br><strong>注</strong>：MVVM 主要解决了 MVC中大量的 DOM 操作使页面渲染性能降低，加载速度变慢</p><h2 id="三-diff算法"><a href="#三-diff算法" class="headerlink" title="三. diff算法"></a>三. diff算法</h2><ul><li>同级比较：减少比较次数</li><li>比较key：相同的元素直接复用，减少不必要的销毁和创建<br>在vue3的diff 算法做了更新</li><li>静态标记</li><li>静态提升</li><li>事件缓存</li></ul>]]></content>
    
    
    <summary type="html">Vue的一些原理概念（服务器渲染、Diff算法、Mvc和MVVM等）</summary>
    
    
    
    <category term="前端" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
    <category term="前端" scheme="https://fanxing28.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://fanxing28.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue-Router (路由)</title>
    <link href="https://fanxing28.github.io/2023/12/03/%E5%89%8D%E7%AB%AF/Vue/Vue-Router%20(%E8%B7%AF%E7%94%B1)/"/>
    <id>https://fanxing28.github.io/2023/12/03/%E5%89%8D%E7%AB%AF/Vue/Vue-Router%20(%E8%B7%AF%E7%94%B1)/</id>
    <published>2023-12-03T14:47:00.000Z</published>
    <updated>2023-12-03T15:05:25.582Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-路由原理"><a href="#一-路由原理" class="headerlink" title="(一) 路由原理"></a>(一) 路由原理</h2><p>利用地址栏url的hash，就是常用的锚点（#）操作，类似页面中点击某小图标，返回页面顶部，JS通过<strong>hashChange事件</strong>来监听url的改变（知识监听hash值的变化，而不是直接切换页面）<br><strong>前端路由的工作方式</strong>：</p><ol><li>用户点击了页面上的路由链接</li><li>导致了 URL 地址栏中的 Hash 值发生了变化</li><li>前端路由通过hashChange事件来监听 Hash 地址的变化</li><li>前端路由把当前 Hash 地址对应的组件渲染到浏览器中<br>a标签中href的属性中加 # 和不加 #的<strong>区别</strong>：</li></ol><ul><li>加了 # 的<strong>不会刷新页面</strong></li><li>不加 # 的<strong>会刷新页面</strong><br><strong>结论</strong>：前端路由，指的是 Hash 地址与组件之间的对应关系！<br><code>this.$router</code> 和 <code>this.$route</code>的区别：</li><li>this.$router：表示整个路由实例</li><li>this.$route：表示当前页面的路由信息</li></ul><h2 id="二-实现路由切换"><a href="#二-实现路由切换" class="headerlink" title="(二) 实现路由切换"></a>(二) 实现路由切换</h2><p><strong>(1) 使用原生js实现路由切换</strong>的步骤：</p><ol><li>需要一些可以改变 url 的按钮，a标签<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#zs&quot;</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#ls&quot;</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>需要一个存放切换内容的容器<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>需要一个<strong>路由表</strong>：就是一个数组，里面每一项是对象（一般至少包含path，template）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&quot;zs&quot;</span>,</span><br><span class="line">        <span class="attr">template</span>:<span class="string">`&lt;div&gt;我叫张三&lt;/div&gt;`</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&quot;ls&quot;</span>,</span><br><span class="line">        <span class="attr">template</span>:<span class="string">`&lt;div&gt;我叫李四&lt;/div&gt;`</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure></li><li>监听url的改变<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;hashchange&quot;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> hash = location.<span class="property">hash</span>.<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">    routes.<span class="title function_">forEach</span>(item,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash === item.<span class="property">path</span>)&#123;</span><br><span class="line">            box.<span class="property">innerHTML</span> = item.<span class="property">template</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><strong>(2) 使用VueRouter实现路由切换</strong>的步骤：</li><li>首先引入Vue和VueRouter<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue@3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue-router@4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>可以通过引入CDN的方式加速加载：<a href="https://www.bootcdn.cn/">BootCDN - Bootstrap 中文网开源项目免费 CDN 加速服务</a><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/vue-router/4.1.6/vue-router.global.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>使用router-link组件（相当于html中的a标签）进行导航，并通过传递to（相当于a标签中href属性）来指定跳转的链接<blockquote><p>注：在使用的时候地址栏会在路径前面自动添加 # (eg：#&#x2F;about)</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>to about<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>使用 router-view 标签作为路由的出口（路由匹配到的组件将渲染到这里）<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>指定路由组件<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Home</span> = &#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">`&lt;div&gt;Home&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Movie</span> = &#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">`&lt;div&gt;Movie&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">About</span> = &#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">`&lt;div&gt;About&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>进行路由映射组件<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>, <span class="attr">component</span>: <span class="title class_">Home</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/movie&quot;</span>, <span class="attr">component</span>: <span class="title class_">Movie</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/about&quot;</span>, <span class="attr">component</span>: <span class="title class_">About</span> &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li>创建路由实例（自动监听url改变）并传递<code>routes</code>配置<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title class_">VueRouter</span>.<span class="title function_">createRouter</span>(&#123;</span><br><span class="line">    <span class="comment">// 内部提供了 history 模式的实现。为了简单起见，我们在这里使用 hash 模式。</span></span><br><span class="line">    <span class="attr">history</span>: <span class="title class_">VueRouter</span>.<span class="title function_">createWebHashHistory</span>(),</span><br><span class="line">    <span class="attr">routes</span>: routes, <span class="comment">// `routes: routes` 的缩写</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>创建并挂载实例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;&#125;);</span><br><span class="line"><span class="comment">// 使用 routes 配置</span></span><br><span class="line">app.<span class="title function_">use</span>(router);</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure><strong>(3) 在项目中使用路由</strong>的步骤：</li><li>安装VueRouter可以在项目创建的时候就添加，也可以后面需要使用的时候在添加，添加方式：<br> npm方式：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router@4</span><br></pre></td></tr></table></figure>yarn方式：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add vue-router@4</span><br></pre></td></tr></table></figure></li><li>在根组件使用 router-link 和 Router-view做路由的跳转和路由出口</li><li>在src目录下新建router目录及创建index.js文件存放所有路由<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入createRouter和createWebHistory</span></span><br><span class="line"><span class="keyword">import</span> &#123;createRouter,createWebHistory&#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"><span class="comment">// 引入每一个路由组件</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 创建了路由实例</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">    history :<span class="title function_">createWebHistory</span>(&#123;<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">BASE_URL</span>&#125;),</span><br><span class="line">    <span class="comment">// 创建路由表</span></span><br><span class="line">    <span class="attr">routes</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&quot;/zs&quot;</span></span><br><span class="line">            <span class="attr">component</span>: <span class="variable constant_">ZS</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    ],</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 对外暴露router</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure></li><li>在main.js入口文件引入router目录，并使用路由 <code>app.use(router)</code><br> 可以通过 <code>this.$route.params.id</code> 拿到动态路由的id</li></ol><h2 id="三-动态路由匹配"><a href="#三-动态路由匹配" class="headerlink" title="(三) 动态路由匹配"></a>(三) 动态路由匹配</h2><h3 id="1-路由跳转传参"><a href="#1-路由跳转传参" class="headerlink" title="(1) 路由跳转传参"></a>(1) 路由跳转传参</h3><p>Vue中路由地址是精准匹配的，在路由路径后加 <code>/:id(或其他变量名)</code>，通过URL跳转传参<br><strong>注</strong>：动态参数也可以传递多个：<code>/:id/:num</code></p><h3 id="2-响应路由参数的变化"><a href="#2-响应路由参数的变化" class="headerlink" title="(2) 响应路由参数的变化"></a>(2) 响应路由参数的变化</h3><p>使用带有参数的路由时需要注意的是，当用户从 <code>/users/johnny</code> 导航到 <code>/users/jolyne</code> 时，<strong>相同的组件实例将被重复使用</strong>。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。<strong>不过，这也意味着组件的生命周期钩子不会被调用</strong>。（这就意味着如果你需要从一个详情页跳转到另外一个详情页时，详情页组件会进行复用）<br>要对同一个组件中参数的变化做出响应的话，你可以简单地 watch <code>$route</code> 对象上的任意属性，在这个场景中，就是 <code>$route.params</code> （可以使用watch进行监听$route(url的改变)）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line">    $route(to,<span class="keyword">from</span>)&#123;</span><br><span class="line">        <span class="comment">//  to：表示要去的页面的路由信息</span></span><br><span class="line">        <span class="comment">// from：表示来自的页面的路由信息</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">id</span> = to.<span class="property">params</span>.<span class="property">id</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，使用 <code>beforeRouteUpdate</code> 导航守卫，它也可以取消导航：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">beforeRouteUpdate</span>(<span class="params">to, <span class="keyword">from</span></span>) &#123;</span><br><span class="line">        <span class="comment">// 对路由变化做出响应...</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">userData</span> = <span class="keyword">await</span> <span class="title function_">fetchUser</span>(to.<span class="property">params</span>.<span class="property">id</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-404路由"><a href="#3-404路由" class="headerlink" title="(3) 404路由"></a>(3) 404路由</h3><p>创建一个404页面<br><strong>注</strong>：需要路由表的最下面加上404路由（因为Vue是排他性路由（从路由表上向下匹配：只要匹配到就不在往下匹配了），React的5版本是包容性路由（会将整个路由表中的路由都匹配一遍：所以有时会同时匹配到多个路由））</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/:pathMatch(.*)*&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">NotFound</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在参数中自定义正则</strong>：就是在动态路由中可以添加一些正则表达式进行更精准的匹配。（eg：<code>/:id(\\d+)</code> ：只匹配数字）<br>后面添加?表示：<strong>动态可选路由</strong>（就是:id可有可没有）（eg: <code>/:id?</code>）</p><h3 id="4-嵌套路由"><a href="#4-嵌套路由" class="headerlink" title="(4) 嵌套路由"></a>(4) 嵌套路由</h3><p>直接在路由表中要加下一级路由的位置添加children属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/hot&quot;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">Hot</span>,</span><br><span class="line">        <span class="comment">// children：表示的是下一级路由，语法和routes完全相同</span></span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">path</span>: <span class="string">&quot;/hot/yesterday&quot;</span>,</span><br><span class="line">                <span class="comment">// 另外一种写法：</span></span><br><span class="line">                <span class="comment">// path: &quot;yesterday&quot;</span></span><br><span class="line">                <span class="attr">component</span>: <span class="title class_">Yesterday</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="四-编程式导航"><a href="#四-编程式导航" class="headerlink" title="(四) 编程式导航"></a>(四) 编程式导航</h2><p>编程式导航指的是通过js的方式做跳转<br><strong>路由跳转的三种方法</strong>：push()、replace()、go()</p><ul><li><strong>push() 方法</strong>是可以在历史记录里面追加，它是可以后退的</li><li><strong>replace() 方法</strong>是替换当前的历史记录，后退的时候回跳过当前页面</li><li><strong>go() 方法</strong>是用于前进或者后退，里面写整数。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串路径</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&#x27;/users/eduardo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带有路径的对象</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/users/eduardo&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名的路由，并加上参数，让路由建立 url</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;user&#x27;</span>, <span class="attr">params</span>: &#123; <span class="attr">username</span>: <span class="string">&#x27;eduardo&#x27;</span> &#125; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带查询参数，结果是 /register?plan=private</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/register&#x27;</span>, <span class="attr">query</span>: &#123; <span class="attr">plan</span>: <span class="string">&#x27;private&#x27;</span> &#125; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带 hash，结果是 /about#team</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>, <span class="attr">hash</span>: <span class="string">&#x27;#team&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure><strong>声明式导航和编程式导航的使用场景</strong>：</li><li>多数情况下，router-link声明式导航和编程式导航是可以换着用</li><li>router-link在使用的过程中，被选中的那一项会自动router-link-active的类名，可以很方便的实现导航高亮（nav导航的时候用）</li><li>需要使用js进行跳转的时候，使用编程式导航</li></ul><h2 id="五-命名路由"><a href="#五-命名路由" class="headerlink" title="(五) 命名路由"></a>(五) 命名路由</h2><p>除了 <code>path</code> 之外，你还可以为任何路由提供 <code>name</code>。这有以下优点：</p><ul><li>没有硬编码的 URL</li><li><code>params</code> 的自动编码&#x2F;解码。</li><li>防止你在 url 中出现打字错误。</li><li>绕过路径排序（如显示一个）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/user/:username&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;user&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">User</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>要链接到一个命名的路由，可以向 <code>router-link</code> 组件的 <code>to</code> 属性传递一个对象：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123; name: &#x27;user&#x27;, params: &#123; username: &#x27;erina&#x27; &#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">  User</span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="六-命名视图"><a href="#六-命名视图" class="headerlink" title="(六) 命名视图"></a>(六) 命名视图</h2><p>有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 <code>sidebar</code> (侧导航) 和 <code>main</code> (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 <code>router-view</code> 没有设置名字，那么默认为 <code>default</code>。<br>用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在路由出口标签上添加name属性 --&gt;</span><br><span class="line">&lt;router-view name=&quot;a&quot;&gt;&lt;router-view&gt;</span><br><span class="line">&lt;router-view name=&quot;h&quot;&gt;&lt;router-view&gt;</span><br><span class="line">&lt;!-- 在路由表中添加多个component --&gt;</span><br><span class="line">&#123;</span><br><span class="line">    path: &#x27;/about&#x27;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        a: about</span><br><span class="line">        h: home</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实在很多时候一般需要添加多个组件时可以将router-view将所有组件进行包裹就行，而命名组件的使用场景可以是在页面需要在不同的地方分别添加路由是使用。<br><strong>使用命名路由</strong>：</p><ol><li>要将component换成components</li><li>在页面里面需要给routerView组件添加name属性</li></ol><h2 id="七-重定向"><a href="#七-重定向" class="headerlink" title="(七) 重定向"></a>(七) 重定向</h2><p>重定向也是通过 <code>routes</code> 配置来完成，下面例子是从 <code>/home</code> 重定向到 <code>/</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [&#123; <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/&#x27;</span> &#125;]</span><br></pre></td></tr></table></figure><p>重定向的目标也可以是一个命名的路由：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [&#123; <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>, <span class="attr">redirect</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;homepage&#x27;</span> &#125; &#125;]</span><br></pre></td></tr></table></figure><h2 id="八-别名"><a href="#八-别名" class="headerlink" title="(八) 别名"></a>(八) 别名</h2><p>别名就是在路由表中添加一个属性alias，用法简单来说就是给一个页面或路由导航添加一个其他的名字。主要是用于取一个十分语义化的别名让其跳转。<br><strong>将props传递给路由组件</strong>：在路由表中添加 props: true 就可以在组件里面直接使用props来接收参数</p><h2 id="九-不同的历史模式"><a href="#九-不同的历史模式" class="headerlink" title="(九) 不同的历史模式"></a>(九) 不同的历史模式</h2><h3 id="1-Hash-模式"><a href="#1-Hash-模式" class="headerlink" title="(1) Hash 模式"></a>(1) Hash 模式</h3><p>引入代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createRouter,createWebHashHistory&#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br></pre></td></tr></table></figure><p>在创建路由实例时使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">    <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">BASE_URL</span>),</span><br><span class="line">    <span class="attr">routes</span>:[</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-history-模式"><a href="#2-history-模式" class="headerlink" title="(2) history 模式"></a>(2) history 模式</h3><p>引入代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createRouter,createWebHistory&#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br></pre></td></tr></table></figure><p>在创建路由实例时使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">    <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">BASE_URL</span>),</span><br><span class="line">    <span class="attr">routes</span>:[</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>Hash模式和history模式的区别</strong>：</p><ul><li>Hash模式url带：”#” （优势：将项目打包放到服务器的时候不会出现问题）</li><li>history模式url不带：”#”（优势：美观，当生产模式的时候会出现页面刷新出现404）问题的解决方式：在后端进行一些配置</li></ul><h3 id="3-abstract-路由模式"><a href="#3-abstract-路由模式" class="headerlink" title="(3) abstract 路由模式"></a>(3) abstract 路由模式</h3><p>主要在app中运行<br>abstract 是vue路由中的第三种模式，本身是用来在不支持浏览器API的环境中，充当fallback，而不论是hash还是history模式都会对浏览器上的url产生作用，本文要实现的功能就是在已存在的路由页面中内嵌其他的路由页面，而保持在浏览器当中依旧显示当前页面的路由path，这就利用到了abstract这种与浏览器分离的路由模式</p><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>主要是新增了两个方法：router.addRoute()<code>和</code>router.removeRoute()</p><blockquote><p>主要用于主动地添加和删除路由用的</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">addRoute</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>, <span class="attr">component</span>: <span class="title class_">About</span> &#125;)</span><br></pre></td></tr></table></figure><p>主要用于后台管理项目中的主要内容区（通过路由显示的）每中不同角色的人进入系统会根据不同的权限选择性的显示功能界面时可以使用这两个方法（并不是说你只要将功能菜单栏来控制不同权限显示不同的界面，但是这样会导致没有权限的人通过在地址栏进行操作也可以看到超出自身权限的内容）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">addRoute</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;about&#x27;</span>, <span class="attr">component</span>: <span class="title class_">About</span> &#125;)</span><br><span class="line"><span class="comment">// 删除路由</span></span><br><span class="line">router.<span class="title function_">removeRoute</span>(<span class="string">&#x27;about&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><h3 id="1-全局前置守卫-beforeEach"><a href="#1-全局前置守卫-beforeEach" class="headerlink" title="(1) 全局前置守卫(beforeEach)"></a>(1) 全局前置守卫(beforeEach)</h3><p><strong>触发时机</strong>：在进入路由页面之前，可以在这个函数中进行判断页面是否应该进入下一个路由<br>只要路由发生改变，那么这个函数（beforeEach）就会执行<br>beforeEach函数有三个参数：</p><ul><li>to：表示的是要去的那个页面的路由信息</li><li>from：表示的是来的那个页面的路由信息</li><li>next：表示放行（false：不放行；true：放行(默认值)）<blockquote><p>如果next()中是一个路由路径，则表示要重定向到那个路由</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123; ... &#125;)</span><br><span class="line"><span class="comment">// 只要路由发生改变，那么这个函数就会执行</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 返回 false 以取消导航</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-全局解析守卫-beforeResolve"><a href="#2-全局解析守卫-beforeResolve" class="headerlink" title="(2) 全局解析守卫(beforeResolve)"></a>(2) 全局解析守卫(beforeResolve)</h3><p>执行时机和作用域以及参数与全局前置守卫几乎一致（执行会稍微慢于beforeEach）<br><strong>唯一区别</strong>：beforeEach和beforeResolve之间有一个<strong>解析异步路由组件</strong>的步骤，等同于在beforeEach的时候异步路由组件还没有解析，而beforeResolve时路由正在解析。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">beforeResolve</span>(<span class="keyword">async</span> to =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (to.<span class="property">meta</span>.<span class="property">requiresCamera</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">askForCameraPermission</span>()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="keyword">if</span> (error <span class="keyword">instanceof</span> <span class="title class_">NotAllowedError</span>) &#123;</span><br><span class="line">                <span class="comment">// ... 处理错误，然后取消导航</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 意料之外的错误，取消导航并把错误传给全局处理器</span></span><br><span class="line">                <span class="keyword">throw</span> error</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="3-全局后置钩子-afterEach"><a href="#3-全局后置钩子-afterEach" class="headerlink" title="(3) 全局后置钩子(afterEach)"></a>(3) 全局后置钩子(afterEach)</h3><p><strong>执行时机</strong>：在跳转路由完成之后触发<br>afterEach函数的参数只有to和from，它没有next</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">sendToAnalytics</span>(to.<span class="property">fullPath</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="4-路由独享守卫-beforeEnter"><a href="#4-路由独享守卫-beforeEnter" class="headerlink" title="(4) 路由独享守卫(beforeEnter)"></a>(4) 路由独享守卫(beforeEnter)</h3><p><strong>触发时机</strong>：在指定的路由要跳进去的时候调用<br>路由独享守卫(beforeEnter)的作用与全局前置守卫一致，只是作用域不同，路由独享守卫(beforeEnter)是对单个路由进行操作，全局前置守卫是在全局进行操作。<br>beforeEnter函数的参数：to、from、next<br>可以直接在路由配置上定义 <code>beforeEnter</code> 守卫：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/users/:id&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">UserDetails</span>,</span><br><span class="line">        <span class="attr">beforeEnter</span>: <span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// reject the navigation</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="5-组件内的守卫"><a href="#5-组件内的守卫" class="headerlink" title="(5) 组件内的守卫"></a>(5) 组件内的守卫</h3><p><strong>可用的配置 API</strong></p><ul><li><code>beforeRouteEnter</code>：路由进入前调用(先请求数据在跳转)：解决网速慢时切换页面白屏问题</li><li><code>beforeRouteUpdate</code>：当路由参数更新（比如猜你喜欢）</li><li><code>beforeRouteLeave</code>：路由离开时调用（阻止跳转）</li></ul><h2 id="路由元信息"><a href="#路由元信息" class="headerlink" title="路由元信息"></a>路由元信息</h2><p>有时，你可能希望将任意信息附加到路由上，如过渡名称、谁可以访问路由等。这些事情可以通过接收属性对象的<code>meta</code>属性来实现，并且它可以在路由地址和导航守卫上都被访问到。定义路由的时候你可以这样配置 <code>meta</code> 字段：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/posts&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">PostsLayout</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;new&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">PostsNew</span>,</span><br><span class="line">        <span class="comment">// 只有经过身份验证的用户才能创建帖子</span></span><br><span class="line">        <span class="attr">meta</span>: &#123; <span class="attr">requiresAuth</span>: <span class="literal">true</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;:id&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">PostsDetail</span></span><br><span class="line">        <span class="comment">// 任何人都可以阅读文章</span></span><br><span class="line">        <span class="attr">meta</span>: &#123; <span class="attr">requiresAuth</span>: <span class="literal">false</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>应用场景</strong>：</p><ol><li>有些页面进入时需要先判断是否登录了，如果登录了才能进入。（此时就可以利用元信息中的属性的属性值的布尔状态来判断是否登录）</li><li>路由切换时更换页面标题<br><strong>路由鉴权</strong>：判断有没有权限来判断你是否可以进入该路由页面</li></ol><h2 id="滚动行为"><a href="#滚动行为" class="headerlink" title="滚动行为"></a>滚动行为</h2><p>使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。<br><strong>注意: 这个功能只在支持 history.pushState 的浏览器中可用。</strong><br>当创建一个 Router 实例，你可以提供一个 <code>scrollBehavior</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(),</span><br><span class="line">  <span class="attr">routes</span>: [...],</span><br><span class="line">  scrollBehavior (to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">    <span class="comment">// return 期望滚动到哪个的位置</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第三个参数 <code>savedPosition</code>，只有当这是一个 <code>popstate</code> 导航时才可用（由浏览器的后退&#x2F;前进按钮触发）。<br>该函数可以返回一个 <code>ScrollToOptions</code> 位置对象:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">scrollBehavior</span>(<span class="params">to, <span class="keyword">from</span>, savedPosition</span>) &#123;</span><br><span class="line">    <span class="comment">// 始终滚动到顶部</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">top</span>: <span class="number">0</span> &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>如果返回一个 falsy 的值，或者是一个空对象，那么不会发生滚动。<br>返回 <code>savedPosition</code>，在按下 后退&#x2F;前进 按钮时，就会像浏览器的原生表现那样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">scrollBehavior</span>(<span class="params">to, <span class="keyword">from</span>, savedPosition</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (savedPosition) &#123;</span><br><span class="line">        <span class="keyword">return</span> savedPosition</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">top</span>: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就会更加高效。<br>也就是说可以用<strong>动态导入代替静态导入</strong>，在需要该路由的时候在进行相应的加载，而不是在应用创建时全部加载。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将</span></span><br><span class="line"><span class="comment">// import UserDetails from &#x27;./views/UserDetails.vue&#x27;</span></span><br><span class="line"><span class="comment">// 替换成</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">UserDetails</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">&#x27;./views/UserDetails.vue&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">routes</span>: [&#123; <span class="attr">path</span>: <span class="string">&#x27;/users/:id&#x27;</span>, <span class="attr">component</span>: <span class="title class_">UserDetails</span> &#125;],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Vue Router 是 Vue.js 的官方路由。它与 Vue.js 核心深度集成，让用 Vue.js 构建单页应用变得轻而易举。功能包括：嵌套路由映射动态路由选择模块化、基于组件的路由配置路由参数、查询、通配符展示由 Vue.js 的过渡系统提供的过渡效果细致的导航控制自动激活 CSS 类的链接HTML5 history 模式或 hash 模式可定制的滚动行为URL 的正确编码</summary>
    
    
    
    <category term="前端" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://fanxing28.github.io/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
    <category term="前端" scheme="https://fanxing28.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://fanxing28.github.io/tags/Vue/"/>
    
  </entry>
  
</feed>
